## 第1 章 Object类

### 1.1 常用的包

- `java.lang`包

    该包是Java语言的核心包，该包中的类和接口由Java虚拟机自动导入。 如：`String`类、`System`类等。

- `java.util`包 

    该包是Java语言的工具包，该包中提供了大量的工具类和集合类。 如：`Scanner`类、`Random`类、`List`接口等。

- `java.io`包 

    该包是Java语言的输入输出包，该包中提供大量操作文件的类。如：``InputStream`类、`OutputStream`类等。

- `java.net`包
    该包是Java语言的网络包，该包中提供大量网络通信的类。 如：`ServerSocket`类和`Socket`类等。



### 1.2 Object类

(1)基本概念
`java.lang.Object`类是所有类层次结构的根类，任何类都是Object类的直接/间接子类。

(2)常用的方法

`Object()`
\- 无参方式构造对象，通常用于子类使用super()方式调用。

`boolean equals(Object obj)`
\- 用于判断调用对象是否和参数对象相等。
\- 该方法默认比较两个对象的地址，与==运算符的效果等价。
\- 若希望该方法比较两个对象的内容，则需要重写该方法。
\- 当该方法被重写时，通常有必要重写`hashCode()`方法。

```java
/**
	测试类
*/
public class Student {
    private int id;      //用于描述学号的成员变量
    private String name; //用于描述姓名的成员变量
    
    // 无参、有参构造方法、set(),get()方法
    
    //由于从Object类中继承的方法不足以满足该类的需求，因此需要重写该方法比较学号
    @Override
    public boolean equals(Object obj){
        //1.判断地址相同则内容一定相同
        if(this == obj) return true;
        //2.判断参数对象为空则内容一定不相同
        if(null == obj) return false;
        //3.判断两个对象的学号是否相同，首先要判断类型是否相同
        if(obj instanceof Student){
            Student ts = (Student)obj;
            return this.getId() == ts.getId();
        }
        return false;
    }
    //若希望该方法与equals()结果保持一致，则需要重写该方法。
    @Override
    public int hashCode(){
        //return getId(); //不再代表内存地址的编号
        int type = 12;
        return type*31 + getId();
    }
    //若希望该方法返回更有意义的数据，则需要重写该方法。
    //取代show()方法的功能
    @Override
    public String toString(){
        return "Student[id = " + getId() + ", name = " + getName() + "]";
    }
} 
```

`int hashCode()`
\- 用于获取调用对象的哈希码值(内存地址的编号)。
\- 若equals()方法比较两个对象相等，则各自调用hashCode()结果必须相同。
\- 若equals()方法比较两个对象不相等，则各自调用hashCode()结果应该不同。
\- 若希望该方法与equals()结果保持一致，则需要重写该方法。

`String toString()`
\- 用于获取调用对象的字符串表示形式。
\- 该方法默认返回：包名.类名@哈希码值的十六进制形式。
\- 若希望该方法返回更有意义的数据，则需要重写该方法。
\- 当使用print/println打印引用时或+连接引用时，会自动 调用该方法。







## 第2 章 包装类和数学处理类

### 2.1 包装类

(1)基本概念
在某些特殊场合(集合)中要求所有的数据内容都必须是对象，但对于num这样的变量来说不符合该要求，此时就需要对变量进行对象化处理包装成类，实现这样功能的类就叫做包装类。

(2)基本分类
`int` => `java.lang.Integer`类
`char` => `java.lang.Character`类
其它类型都是首字母变大写即可

### 2.2 Integer类

(1)基本概念
`java.lang.Integer`类是int类型的包装类，该类由final修饰表示不能被继承。

(2)常用的方法
`Integer(int value)` - 根据参数指定的整数来构造对象。

`Integer(String s)` - 根据参数指定的字符串来构造对象。

```java
public class TestInteger {
    public static void main(String[] args) {
        //1.使用Integer类型的引用指向Integer类型的对象
        Integer it1 = new Integer(123);
        System.out.println("it1 = " + it1); //自动调用toString String类型  123
        Integer it2 = new Integer("20");
        //Integer it2 = new Integer("20a");//编译ok 
        //运行发生 NumberFormatException  数字格式异常
        System.out.println("it2 = " + it2); //String类型 20
        System.out.println("-----------------------------------");
        //2.实现Integer类型和int类型之间的转换
        //实现从Integer类型到int类型的转换，叫做拆箱机制
        int num = it1.intValue();
        System.out.println("num = " + num); //int类型  123
        //实现从int类型到Integer类型的转换，叫做装箱机制
        Integer it3 = Integer.valueOf(num);
        System.out.println("it3 = " + it3); //String类型 123
        //实现从String类型到int类型的转换
        int res = Integer.parseInt("12345");
        System.out.println("res = " + res); //int类型  12345
        System.out.println("-----------------------------------");
        //3.见识一下自动装箱和自动拆箱机制
        Integer it4 = 10; //自动装箱
        int ia = it4;     //自动拆箱
        System.out.println("-----------------------------------");
        //4.笔试题的考点   
        Integer it5 = 128;
        Integer it6 = 128;
        Integer it7 = new Integer(127);
        Integer it8 = new Integer(127);
        System.out.println(it5 == it6);     //比较地址   false  true
        System.out.println(it5.equals(it6));//比较内容   true
        System.out.println(it7 == it8);     //比较地址   false
        System.out.println(it7.equals(it8));//比较内容   true
    }
}  
```

该类重写了equals()方法、hashCode()方法以及toString()方法。
`int intValue()` - 用于获取调用对象中包装的整数数据并返回。

`static Integer valueOf(int i)` - 根据参数指定的整数得到Integer类型对象并返回。

`static int parseInt(String s)` - 用于将String类型转换为int类型(掌握)。

(3)装箱和拆箱
装箱主要指从int类型向Integer类型的转换过程。
拆箱主要指从Integer类型向int类型的转换过程。
从jdk1.5开始支持自动装箱和自动拆箱机制。

(4)自动装箱池(笔试题)
为了提高效率在Integer类的内部提前将-128到127之间的所有整数装箱完毕并放入**自动装箱池**中，若程序中出现该范围的整数则直接从池中取出使用即可。



### 2.3 BigDecimal类

(1)基本概念
由于double类型的数据在运算时可能会有误差，若希望实现精确的运算则使用`java.math.BigDecimal`类型加以描述。

(2)常用的方法
`BigDecimal(String val)`
\- 根据参数指定的字符串构造对象。

`BigDecimal add(BigDecimal augend)`
\- 计算调用对象和参数对象的和并返回。

`BigDecimal subtract(BigDecimal subtrahend)`
\- 计算调用对象和参数对象的差并返回。

`BigDecimal multiply(BigDecimal multiplicand)` - 计算调用对象和参数对象的积并返回。

`BigDecimal divide(BigDecimal divisor)`
\- 计算调用对象和参数对象的商并返回。

```java
public class TestBigDecimal {
    public static void main(String[] args) {
        //1.使用BigDecimal类型的引用指向该类型的对象
        BigDecimal bd1 = new BigDecimal("5.2");
        BigDecimal bd2 = new BigDecimal("1.3");
        //2.调用成员方法实现加减乘除运算并打印结果
        System.out.println("计算的和是：" + bd1.add(bd2));     //6.5
        System.out.println("计算的差是：" + bd1.subtract(bd2));//3.9
        System.out.println("计算的积是：" + bd1.multiply(bd2));//6.76
        System.out.println("计算的商是：" + bd1.divide(bd2));  //4
        System.out.println("------------------------------------------");
        System.out.println(0.1 + 0.2); //0.30000000000000004
        //3.使用BigDecimal类型实现精确运算
        BigDecimal bd3 = new BigDecimal("0.1");
        BigDecimal bd4 = new BigDecimal("0.2");
        System.out.println("精确计算的结果是：" + bd3.add(bd4)); //0.3
        System.out.println("------------------------------------------");
        //4.注意事项
        BigDecimal bd5 = new BigDecimal("0.3");
        //System.out.println("最终的商是：" + bd3.divide(bd5)); //产生算术异常
        //进行四舍五入的方式处理  0.3
        System.out.println("最终的商是：" + bd3.divide(bd5, 
                BigDecimal.ROUND_HALF_UP)); 
    }
}
```

### 2.4 BigInteger类

(1)基本概念
由于long类型存储的数值范围依然有限，若希望描述更大的数据则使用`java.math.BigInteger`类型加以描述。

(2)常用的方法
`BigInteger(String val)`
\- 根据参数指定的字符串来构造对象。

`BigInteger add(BigInteger val)`
\- 用于计算调用对象和参数对象的和并返回。

`BigInteger subtract(BigInteger val)`
\- 用于计算调用对象和参数对象的差并返回。

`BigInteger multiply(BigInteger val)`
\- 用于计算调用对象和参数对象的积并返回。

`BigInteger divide(BigInteger val)`
\- 用于计算调用对象和参数对象的商并返回。

`BigInteger remainder(BigInteger val)`
\- 用于计算调用对象和参数对象的余数并返回。

`BigInteger[] divideAndRemainder(BigInteger val)`
\- 用于计算调用对象和参数对象的商和余数并组成数组并返回。

```java
public class TestBigInteger {
    public static void main(String[] args) {
        //1.声明BigInteger类型的引用指向该类型的对象
        BigInteger bi1 = new BigInteger("12");
        BigInteger bi2 = new BigInteger("4");
        //2.调用成员方法实现加减乘除取余运算并打印出来
        System.out.println("计算的和是：" + bi1.add(bi2));      //16
        System.out.println("计算的差是：" + bi1.subtract(bi2)); //8
        System.out.println("计算的积是：" + bi1.multiply(bi2)); //48
        System.out.println("计算的商是：" + bi1.divide(bi2));   //3
        System.out.println("计算的余数是：" + bi1.remainder(bi2));//0
        System.out.println("------------------------------");
        //3.计算调用对象和参数对象的商和余数并返回
        BigInteger[] arr = bi1.divideAndRemainder(bi2);
        System.out.println("数组的长度是：" + arr.length); //2
        System.out.println("计算的商是：" + arr[0]);       //3
        System.out.println("计算的余数是：" + arr[1]);     //0
    }
}
```







## 第3 章 String类

### 3.1 基本概念

`java.lang.String`类用于描述字符串，Java程序中的所有字符串字面值都可以使用该类的实例/对象加以描述，如: "hello"。
**该类描述的字符串内容是个常量不可改变，因此可以被共享使用。**
**该类由final关键字修饰表示不能被继承**。
如：
String s1 = "hello";
s1 = "world";
\- 改变引用的指向而不是指向的内容。

![String常量池](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20201212165215.jpg)



### 3.2 常量池

由于字符串内容是个常量不可改变，因此Java虚拟机将程序中每次出现的字符串字面值放入**常量池**中，若下次再出现重复的字符串内容则直接使用池中对象即可而无需创建新的对象，从而提高性能。

```java
public class TestString {
    public static void main(String[] args) {
        //笔试题：常量池
        String s1 = "hello";  //常量池
        String s2 = "hello";
        System.out.println(s1 == s2);      //比较地址  true
        System.out.println(s1.equals(s2)); //比较内容  true
        System.out.println("-----------------------------------------");
        //提问：该行代码中创建了几个对象？分别存放在哪里？
        //解析：2个对象，1个在常量池   1个堆区
        String s3 = new String("abc");
        String s4 = new String("abc");
        String s5 = "abc";
        System.out.println(s3 == s4);      //比较地址  false
        System.out.println(s3.equals(s4)); //比较内容  true
        System.out.println(s4 == s5);      //比较地址  false
        System.out.println(s4.equals(s5)); //比较内容  true
        System.out.println("-----------------------------------------");
        String s6 = "ab" + "c";           //常量优化机制  "abc"  常量池
        System.out.println(s6 == s5);     //比较地址  true
        System.out.println(s6.equals(s5));//比较内容  true
        System.out.println(s6 == s4);     //比较地址  false
        System.out.println(s6.equals(s4));//比较内容  true
        System.out.println("-----------------------------------------");
        String s7 = "ab";
        String s8 = s7 + "c";             //s7是个变量，不能优化
        System.out.println(s8 == s6);     //比较地址  false
        System.out.println(s8.equals(s6));//比较内容  true
    }
}
```



### 3.3 常用的方法

(1)常用的**构造方法**
`String()`
\- 使用无参方式构造对象得到空字符序列，如:""

`String(byte[] bytes, int offset, int length)`
\- 使用bytes数组中下标从offset位置开始的length个字节来构造对象。

`String(byte[] bytes)`
\- 使用bytes数组中的所有内容构造对象。

`String(char[] value, int offset, int count)`
\- 使用value数组中下标从offset位置开始的count个字符来构造对象。

`String(char[] value)`
\- 使用value数组中的所有内容构造对象。

`String(String original)`
\- 根据参数指定的字符串内容来构造对象，新创建对象为参数对象的副本。

```java
public class TestStringConstructor {
    public static void main(String[] args) {
        //1.使用无参的方式构造对象
        String s1 = new String();
        System.out.println("s1 = " + s1); //自动调用toString()  s1 = 啥也没有
        System.out.println("------------------------------------");
        //2.使用字节数组来构造对象
        byte[] bArr = {97, 98, 99, 100, 101};
        //使用字节数组中的一部分内容来构造字符串对象
        //使用数组bArr中下标从1开始的3个字节来构造字符串对象，bcd
        String s2 = new String(bArr, 1, 3);
        System.out.println("s2 = " + s2); //bcd
        //使用整个字节数组来构造字符串
        String s3 = new String(bArr);
        System.out.println("s3 = " + s3); //abcde
        System.out.println("------------------------------------");
        //3.使用字符数组来构造对象
        char[] cArr = {'h', 'e', 'l', 'l', 'o'};
        //使用字符数组中的一部分内容构造对象，从下标0开始的3个字符构造
        String s4 = new String(cArr, 0, 3);
        System.out.println("s4 = " + s4); //hel
        //使用整个字符数组来构造对象
        String s5 = new String(cArr);
        System.out.println("s5 = " + s5); //hello
        System.out.println("------------------------------------");
        //4.使用字符串内容来构造对象
        String s6 = new String("world");
        System.out.println("s6 = " + s6); //world
    }
}
```

注意：
""和null之间的区别：
a.""表示有字符串对象，但里面没有存放数据内容；
b.null表示没有字符串对象，调用方法会引发空指针异常；

(2)常用的**成员方法**
该类重写了equals()、hashCode()以及toString()方法。
`char charAt(int index)`
\- 根据参数指定的下标返回对应的单个字符。
`int length()`
\- 用于返回当前字符串的长度。

```java
public class TestStringChar {
    public static void main(String[] args) {
        //1.声明String类型的引用指向该类型的对象
        String s1 = new String("GoodMorning!");
        //2.打印字符串长度，然后取出该字符串中的每个字符并打印出来
        //数组名.length - 用于获取数组的长度，切记没有()   因为是数组的特征
        //字符串.length() - 用于获取字符串的长度，切记有() 因为是成员方法的调用
        System.out.println("字符串的长度是：" + s1.length());
        for(int i = 0; i < s1.length(); i++){
            System.out.println("下标为" + i + "的单个字符是：" + s1.charAt(i));
        }
        //编译ok  运行发生StringIndexOutOfBoundsException字符串下标越界异常
        //System.out.println("下标为12的单个字符是：" + s1.charAt(12));
        System.out.println("--------------------------------------------");
        //3.笔试题的考点：编程使用两种方式实现字符串向整数的转换
        String s2 = new String("12345");
        //方式一：调用Integer类的parseInt()方法实现转换
        int ia = Integer.parseInt(s2);
        System.out.println("ia = " + ia); //ia = 12345
        //实现int类型向String类型的转换  static String valueOf(int i) 
        //String s3 = String.valueOf(ia);
        String s3 = "" + ia; //推荐该方式
        System.out.println("s3 = " + s3); //s3 = 12345
        //方式二：利用ASCII来实现字符串向整数的转换  '1'-'0'=> 1  '2'-'0' => 2
        int ib = 0;
        for(int i = 0; i < s2.length(); i++){
            ib = ib*10 + (s2.charAt(i)-'0');
        }
        System.out.println("ib = " + ib); //ib = 12345
    }
}   
```

`int compareTo(String anotherString)`
\- 用于比较调用对象和参数对象的大小关系。
\- 使用调用对象和参数对象中第一个字符起依次做减法运算
\- 若第一个字符能确定大小，则后续字符不用比较
\- 若第一个字符不能确定大小，则使用下一个对应位置的字符比较大小。
\- 直到其中一个字符串的所有字符比较完毕后也没有确定大小，则由长度来决定大小。
\- 若当前字符串大则返回正数；若当前字符串小则返回负数；若相等则返回零；
`int compareToIgnoreCase(String str)`
\- 不考虑大小写，也就是'a'和'A'是相等的关系。

```java
public class TestStringCompareTo {
    public static void main(String[] args) {
        //1.声明String类型的引用指向String类型的对象
        //String s1 = "hello";    //创建1个对象，放在常量池
        String s1 = new String("hello"); 
        //创建2个对象  1个在常量池 1个堆区 s1指向堆区
        //2.比较字符串的大小并打印结果
        System.out.println(s1.compareTo("world"));//'h'-'w'=> 104-119 => -15 
        System.out.println(s1.compareTo("haha")); //'e'-'a'=> 101-97  => 4
        System.out.println(s1.compareTo("hehe")); //'l'-'h'=> 108-104 => 4
        System.out.println(s1.compareTo("heihei"));//'l'-'i'=>108-105 => 3
        System.out.println(s1.compareTo("helloworld"));//长度：5-10   => -5
        System.out.println(s1.compareTo("HELLO")); //'h'-'H'=>104-72 =>32
        System.out.println(s1.compareToIgnoreCase("HELLO"));//0 相等
    }
}       
```

`boolean contains(CharSequence s)`
\- 用于判断当前字符串是否包含参数指定的内容。
\- 其中参数是接口类型，因此实参需要传递实现类的对象，而String类就实现了该接口
`boolean endsWith(String suffix)`
\- 判断当前字符串是否以参数指定的内容为结尾。
`boolean startsWith(String prefix)`
\- 判断当前字符串中是否以参数指定的内容为开头。
`String toLowerCase()`
\- 用于将当前字符串中所有字符转换为小写。
`String toUpperCase()`
\- 用于将当前字符串中所有字符转换为大写。
`String trim()`
\- 用于去除当前字符串中两端的空白字符。

```java
public class TestStringManyMethod {
    public static void main(String[] args) {
        //1.声明String类型的引用指向String类型的对象
    String s1 = new String("     Let Me Give You Some Color To See See!");
        //2.调用成员方法实现测试
        //判断当前字符串中是否包含指定的内容
        boolean b1 = s1.contains("color");
        System.out.println("b1 = " + b1); //false
        b1 = s1.contains("Color");
        System.out.println("b1 = " + b1); //true
        System.out.println("------------------------------------");
        //判断当前字符串是否以指定的内容结尾
        b1 = s1.endsWith("See");
        System.out.println("b1 = " + b1); //false 
        b1 = s1.endsWith("See!");
        System.out.println("b1 = " + b1); //true
        //判断当前字符串是否以指定的内容开头
        b1 = s1.startsWith("Let");
        System.out.println("b1 = " + b1); //false
        b1 = s1.startsWith(" ");
        System.out.println("b1 = " + b1); //true
        System.out.println("------------------------------------");
        //实现将当前字符串中的所有字符转换为大写并打印
        String s2 = s1.toUpperCase();
        //     LET ME GIVE YOU SOME COLOR TO SEE SEE!
        System.out.println("s2 = " + s2); 
        //     Let Me Give You Some Color To See See!
        System.out.println("s1 = " + s1);
        //实现将当前字符串中的所有字符转换为小写并打印
        String s3 = s1.toLowerCase();
        //     let me give you some color to see see!
        System.out.println("s3 = " + s3);
        System.out.println("------------------------------------");
        //实现去除两端的空白字符
        String s4 = s1.trim();
        //let me give you some color to see see!
        System.out.println("s4 = " + s4);
        //     let me give you some color to see see!
        System.out.println("s1 = " + s1);
    //练习：提示用户输入用户名和密码信息，若输入的内容是"admin"和"123456"则
    // 提示登录成功，否则提示登录失败，若超过3次没有成功则提示"账户已冻结"
    }
}
```

`boolean equals(Object anObject)`
\- 用于比较字符串内容是否相等并返回；
`boolean equalsIgnoreCase(String anotherString)`
\- 用于比较字符串内容是否相等并返回，不考虑大小写，如：'A'和'a'是相等。

```java
public class TestStringEquals {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        for(int i = 3; i > 0; i--){
            //1.提示用户输入用户名和密码信息并使用变量记录
            System.out.println("请输入用户名和密码信息：");
            String userName = sc.next(); 
            String passWord = sc.next();
            //2.判断用户输入的内容是否为"admin"和"123456"，若是则提示登录成功
            //从结果来说：
            userName.equals("admin")   "admin".equals(userName) => 推荐
            if("admin".equalsIgnoreCase(userName)
            && "123456".equals(passWord)){
                System.out.println("登录成功，欢迎使用！");
                break;
            }
            //4.当输入3次依然没有成功，则提示用户"账户已冻结，请联系客服人员！"
            if(1 == i){
                System.out.println("账户已冻结，请联系客服人员！");
                break;
            }
            //3.若不是则提示登录失败
            //else{
            System.out.println("用户名或密码错误，你还有" + (i-1) + "次机会！");
            //}
        }
        //break会跳到这里了
    }
}
```

`byte[] getBytes()`
\- 用于将当前字符串内容转换为byte数组并返回。

`char[] toCharArray()`
\- 用于将当前字符串内容转换为char数组并返回。

```java
public class TestStringByteChar {
    public static void main(String[] args) {
        //1.声明String类型的引用指向该类型的对象
        String s1 = new String("Happy Wife, Happy Life!");
        //2.调用成员方法实现String类型到byte数组的转换  
        //将每个字符转换为对应的ASCII
        byte[] bArr = s1.getBytes();
        //打印字节数组中的每个字节的数据内容
        for(int i = 0; i < bArr.length; i++){
            System.out.println("bArr[" + i + "] = " + bArr[i] 
        }
        //实现将字节数组转回字符串
        String s2 = new String(bArr);
        System.out.println("s2 = " + s2); //Happy Wife, Happy Life!
        System.out.println("----------------------------------------");
        //3.调用成员方法实现String类型到char数组的转换
        //将字符串中的每个字符拆分下来即可
        char[] cArr = s1.toCharArray();
        //打印字符数组中的所有内容
        for(int i = 0; i < cArr.length; i++){
            System.out.println("cArr[" + i + "] = " + cArr[i]);
        }
        //实现字符数组到String类型的转换
        String s3 = new String(cArr);
        System.out.println("s3 = " + s3);//Happy Wife, Happy Life!
    }
}
```

`int indexOf(int ch)`
\- 用于返回当前字符串中参数ch指定的字符第一次出现的下标。

`int indexOf(int ch, int fromIndex)`
\- 用于从fromIndex位置开始查找ch指定的字符。
\- 上述方法若查找失败，则返回-1.

`int indexOf(String str)`
\- 用于查找参数str指定的字符串并返回下标。

`int indexOf(String str, int fromIndex)`
\- 用于从fromIndex位置开始查找。

`int lastIndexOf(int ch)`
\- 用于返回参数ch指定的字符最后一次出现的下标。

`int lastIndexOf(int ch, int fromIndex)`
\- 用于从fromIndex位置开始查找ch指定字符出现的下标，反向搜索的第一次。

`int lastIndexOf(String str)`
\- 用于返回str指定字符串最后一次出现的下标。

`int lastIndexOf(String str, int fromIndex)`
\- 用于从fromIndex位置开始反向搜索的第一次。

```java
public class TestStringIndex {
    public static void main(String[] args) {
        //1.声明String类型的引用指向该类型的对象
        String s1 = new String("Good Good Study, Day Day Up!");
        //2.调用成员方法查找指定的字符和指定的字符串
        //查找参数指定的单个字符第一次出现的索引位置
        int pos = s1.indexOf('g');
        System.out.println("pos = " + pos); //-1
        pos = s1.indexOf('G');
        System.out.println("pos = " + pos); //0
        //从下标0的位置开始查找G第一次出现的位置
        pos = s1.indexOf('G', 0);
        System.out.println("pos = " + pos); //0
        pos = s1.indexOf('G', 1);
        System.out.println("pos = " + pos); //5
        System.out.println("---------------------------------------");
        //查找参数指定的单个字符串第一次出现的索引位置
        //"Good Good Study, Day Day Up!"
        pos = s1.indexOf("day");
        System.out.println("pos = " + pos); //-1
        pos = s1.indexOf("Day");
        System.out.println("pos = " + pos); //17
        //从下标17的位置开始查找
        pos = s1.indexOf("Day", 17);
        System.out.println("pos = " + pos); //17
        pos = s1.indexOf("Day", 18);
        System.out.println("pos = " + pos); //21
        System.out.println("---------------------------------------");
        //练习：编写通用代码实现从字符串s1中将所有"Day"出现的位置找到并打印出来
        //"Good Good Study, Day Day Up!"
        //查找s1中"Day"第一个出现的位置
        pos = s1.indexOf("Day");
        while(pos != -1){
            System.out.println("出现的下标是：" + pos); //17
            //查找该字符串下一次出现的索引位置
            pos = s1.indexOf("Day", pos+1); //18   20
        }
        System.out.println("---------------------------------------");
        //见识一下更加帅气的写法  尽量掌握
        pos = 0;
        while((pos = s1.indexOf("Day", pos)) != -1){
            System.out.println("出现的下标是：" + pos); //17  21
            //当前字符串"Day"自身的长度占3
            pos += "Day".length(); //17 += 3   => 20 => 24
        }
        System.out.println("---------------------------------------");
        //3.使用lastIndexOf()方法实现从后向前反向搜索
        pos = s1.lastIndexOf("day");
        System.out.println("pos = " + pos); //-1
        pos = s1.lastIndexOf("Day");
        System.out.println("pos = " + pos); //21
        //从下标21的位置开始从后向前查找第一次出现的索引位置
        pos = s1.lastIndexOf("Day", 21);
        System.out.println("pos = " + pos); //21
        pos = s1.lastIndexOf("Day", 20);
        System.out.println("pos = " + pos); //17
        pos = s1.lastIndexOf("Day", 16);
        System.out.println("pos = " + pos); //-1
    }
} 
```

`String substring(int beginIndex)`
\- 用于获取当前字符串中从beginIndex位置开始的子字符串并返回。

`String substring(int beginIndex, int endIndex)`
\- 用于获取当前字符串中从beginIndex位置开始到endIndex结尾的子字符串并返回。

```java
public class TestStringSubString {
    public static void main(String[] args) {
        //1.声明String类型的引用指向String类型的对象
        String s1 = new String("As Far As You Die");
        //2.调用成员方法实现字符串中子字符串的获取
        //从s1字符串中下标为3的位置开始取出子字符串
        String s2 = s1.substring(3);
        System.out.println("s2 = " + s2); //Far As You Die
        System.out.println("s1 = " + s1); //As Far As You Die
        System.out.println("---------------------------------");
        //3.指定起始下标和结尾下标，包含4但不包含8
        String s3 = s1.substring(4, 8);
        System.out.println("s3 = " + s3); //ar A
    }
}
```





### 3.4 正则表达式

(1)基本概念
正则表达式本质上就是一个字符串，用于对用户输入的数据内容进行格式的验证。
该字符串通常使用^符号作为开头标志，使用$符号作为结尾标志，也可以省略标志。

(2)常用的规则
[abc] - 表示可以出现a、b 或 c（简单类）。
[^abc] - 表示可以出现任何字符，除了 a、b 或 c（否定）。
[a-zA-Z] - 表示可以出现a 到 z 或 A 到 Z，两头的字母包括在内（范围）。

\d - 表示可以出现任何数字，相当于[0-9]。
\D - 表示可以出现任何非数字，相当于[^0-9]。
\s - 表示可以出现任何空白字符：[ \t\n\x0B\f\r]
\S - 表示可以出现任何非空白字符：[^\s]。
\w - 表示可以出现任何单词字符：[a-zA-Z_0-9]
\W - 表示可以出现任何非单词字符：[^\w]

X? - 表示X可以出现一次或一次也没有，也就是0 ~ 1次。
X* - 表示X可以出现零次或多次，也就是0 ~ n次。
X+ - 表示X可以出现一次或多次，也就是1 ~ n次。
X{n} - 表示X可以出现恰好 n 次。
X{n,} - 表示X可以出现至少 n 次，也就是>=n次。
X{n,m} - 表示X可以出现至少 n 次，但是不超过 m 次，也就是>=n次并且<=m次。

(3)相关的方法
`boolean matches(String regex)`
\- 用于判断当前字符串内容是否满足参数指定的规则。

```java
public class TestStringReg {
    public static void main(String[] args) {
        //1.准备描述正则表达式规则的字符串
        //描述银行卡密码的规则，要求必须是由6位数字组成
        //String reg = "^[0-9]{6}$";
        //String reg = "^\\d{6}$";
        //String reg = "\\d{6}";
        //描述手机号码的规则，要求必须是11位数字组成，必须是1开头  
        //第二位数字必须是3458
        //String reg = "^[1]{1}[3458]{1}\\d{9}$";
        //描述身份证号码的规则，6位数字代表地区  4位数字代表年份 2位数字代表月份
        //2位数字代表日期  3位数字  最后一位数字或者X
        //String reg = "^\\d{6}\\d{4}\\d{2}\\d{2}\\d{3}[0-9|X]{1}$";
        //描述邮箱的规则，xiaomg_123@163.com
        //要求邮箱名称由数字、字母下划线组成，至少1位，  @固定出现
        //要求2~5位字母和数字组成   常见的后缀
        //String reg = "^\\w{1,}[@]{1}[a-zA-Z0-9]
         {2,5}(.com|.cn|.org|.com.cn|.edu)$";
        String reg = "^(\\d{6})(\\d{4})(\\d{2})(\\d{2})(\\d{3})([0-9]|X)$";
        //2.提示用户输入指定业务的字符串内容并使用变量记录
        Scanner sc = new Scanner(System.in);
        for(;;){
            System.out.println("请输入您的银行卡密码：");
            String str = sc.next();
            //3.判断用户输入的字符串内容是否满足上述正则表达式的规则并给出对应的提示
            if(str.matches(reg)){
                System.out.println("格式正确！");
                break;
            }else{
                System.out.println("格式不正确！！！");
            }
        }
    }
}     
```







## 第4 章 StringBuilder类和StringBuffer类

### 4.1 基本概念

由于String类描述的字符串内容是个常量不可改变，若程序中出现大量相似的字符串时使用String类型描述则需要单独存储，此时对内存空间的消耗比较大。
为了解决上述问题，希望直接修改字符串内容，则使用StringBuilder类或StringBuffer类加以描述。
其中`StringBuffer`类从jdk1.0开始出现，属于线程安全的类，因此效率比较低；
其中`StringBuilder`类从jdk1.5开始出现，属于非线程安全的类，因此效率比较高；

### 4.2 常用的方法

`StringBuilder(String str)`
\- 根据参数指定的字符串来构造对象。
\- 其中初始容量为：字符串的长度 + 16。

`int capacity()`
\- 用于返回调用对象的容量。

`int length()`
\- 用于返回调用对象的长度/字符的个数。

`StringBuilder insert(int offset, String str)`
\- 用于将参数str代表的内容插入到当前字符串中下标为offset的位置上。
\- 返回当前对象的引用，也就是当前对象自己。

`StringBuilder append(String str)`
\- 用于将参数str代表的内容追加到当前字符串的末尾。

`StringBuilder delete(int start, int end)`
\- 用于将当前字符串中从start位置(含)开始到end位置(不含)结束之间的内容删除。

`StringBuilder deleteCharAt(int index)`
\- 用于将当前字符串中下标为index位置的单个字符删除。

`StringBuilder replace(int start, int end, String str)`
\- 用于将当前字符串中从start位置到end位置之间的内容使用str替换掉。

`void setCharAt(int index, char ch)`
\- 用于将当前字符串中下标为index位置的单个字符修改为参数ch的数值。

`int indexOf(String str)`
\- 用于在当前字符串中查找参数str第一次出现的索引位置。

`StringBuilder reverse()`
\- 用于实现字符串内容的反转。

```java
public class TestStringBuilder {
    public static void main(String[] args) {
        //1.声明StringBuilder类型的引用指向该类型的对象
        StringBuilder sb1 = new StringBuilder("hello");
        //2.获取该对象的容量和长度并打印
        System.out.println("调用对象的容量是：" + sb1.capacity()); //21=5+16
        System.out.println("调用对象的长度是：" + sb1.length());   //5
        System.out.println("------------------------------------------");
        String s1 = "hello";
        String s2 = s1.toUpperCase();
        System.out.println("s2 = " + s2); //HELLO
        System.out.println("s1 = " + s1); //hello
        //3.调用insert方法向字符串中插入字符串内容
        //向字符串开头位置(下标0)插入abcd
        StringBuilder sb2 = sb1.insert(0, "abcd");
        System.out.println("sb2 = " + sb2); //abcdhello
        System.out.println("sb1 = " + sb1); //abcdhello
        System.out.println("--------------------------------------");
        //向中间位置插入字符串内容
        sb1.insert(4, "1234");
        System.out.println("sb1 = " + sb1); //abcd1234hello
        //向末尾位置插入字符串内容
        sb1.insert(sb1.length(), "ABCD");
        System.out.println("sb1 = " + sb1); //abcd1234helloABCD
        System.out.println("--------------------------------------");
        //4.实现向字符串末尾追加数据内容
        sb1.append("world");
        System.out.println("sb1 = " + sb1); //abcd1234helloABCDworld
        //当插入的字符串内容超过了初始容量时会自动扩容，而扩容的具体算法需要查看源码
        System.out.println("调用对象的容量是：" + sb1.capacity()); //44
        System.out.println("调用对象的长度是：" + sb1.length());   //22
        System.out.println("--------------------------------------");
        System.out.println("sb1 = " + sb1); //abcd1234helloABCDworld
        //5.实现字符串内容的删除
        //删除中间内容  起始下标为8，结尾下标为13，包含8但不包含13 
        sb1.delete(8, 13);
        System.out.println("sb1 = " + sb1); //sb1 = abcd1234ABCDworld
        //删除开头位置的内容
        sb1.delete(0, 4);
        System.out.println("sb1 = " + sb1); //sb1 = 1234ABCDworld
        //删除末尾位置的内容
        sb1.delete(8, sb1.length());
        System.out.println("sb1 = " + sb1); //sb1 = 1234ABCD
        //删除单个字符 '4'
        sb1.deleteCharAt(3);
        System.out.println("sb1 = " + sb1); //sb1 = 123ABCD
        //删除所有内容
        //sb1.delete(0, sb1.length());
        //System.out.println("sb1 = " + sb1); //sb1 = 啥也没有
        System.out.println("--------------------------------------");
        //6.实现字符串内容的修改
        //实现将起始位置3到结尾位置.length之间的内容使用abcd替换
        sb1.replace(3, sb1.length(), "abcd");
        System.out.println("sb1 = " + sb1); //123abcd
        //将下标为3的单个元素替换为A
        sb1.setCharAt(3, 'A');
        System.out.println("sb1 = " + sb1); //123Abcd
        System.out.println("--------------------------------------");
        //7.实现字符串内容的查找和反转
        int pos = sb1.indexOf("a");
        System.out.println("查找到的下标位置是：" + pos); //-1
        pos = sb1.indexOf("A");
        System.out.println("查找到的下标位置是：" + pos); //3
        //实现反转
        sb1.reverse();
        System.out.println("sb1 = " + sb1); //dcbA321
        System.out.println("--------------------------------------");
        //8.既然这些方法的返回值代表的就是当前对象自己，那么为啥还需要返回值呢？
        //解析：为了连续调用
        StringBuilder sb3 = sb1.reverse();
        System.out.println("sb1 = " + sb1); //123Abcd
        System.out.println("sb3 = " + sb3); //123Abcd
        //sb1.append("1").insert(0, "2").replace(0, 1, "3").reverse().length();
        System.out.println("--------------------------------------");
        //9.如何实现String类型和StringBuilder类型之间的转换
        String s3 = "GoodAfternoon!";
        //实现String类型到StringBuilder类型的转换
        StringBuilder sb4 = new StringBuilder(s3);
        System.out.println("sb4 = " + sb4); //GoodAfternoon!
        //实现StringBuilder类型到String类型的转换
        String s4 = sb4.toString();
        System.out.println("s4 = " + s4); //GoodAfternoon!
    }
}
```







## 第5 章 日期相关的类

### 5.1 Date类

(1)基本概念
`java.util.Date`类用于描述特征的瞬间，可以精确到毫秒数。

(2)常用的方法
`Date()`
\- 使用无参的方式构造对象，默认采用当前系统时间来初始化。

`Date(long date)`
\- 根据参数指定的毫秒数来构造对象。
\- 其中参数为距离1970年1月1日0时0分0秒以来的毫秒数。 - 1秒 = 1000毫秒
\- 与后期要学的File类中的方法搭配使用。

`long getTime()`
\- 用于获取当前调用对象距离1970年1月1日0时0分0秒的毫秒数。

`void setTime(long time)`
\- 用于设置当前调用对象的时间为距离1970年1月1日0时0分0秒的毫秒数。

```java
public class TestDate {
    public static void main(String[] args) {
        //1.使用无参方式构造对象并打印
        Date d1 = new Date();
        System.out.println("d1 = " + d1); //自动调用toString()
        System.out.println("---------------------------------");
        //2.使用有参方式构造对象并打印
        Date d2 = new Date(1000);
        System.out.println("d2 = " + d2);
        System.out.println("---------------------------------");
        //3.获取调用对象距离标准时间的毫秒数
        long msec = d1.getTime();
        System.out.println("当前系统时间距离标准时间的毫秒数为：" + msec);
        //4.设置调用对象d1的时间为距离标准时间2秒的时间点
        d1.setTime(2000);
        System.out.println("d1 = " + d1); 
    }
}       
```

### 5.2 SimpleDateFormat类

(1)基本概念
`java.text.SimpleDateFormat`类主要用于实现日期和文本之间的转换。

(2)常用的方法
`SimpleDateFormat(String pattern)`
\- 根据参数指定的模式来构造对象。
\- 常用的模式有：y-年 M-月 d-日 H-时 m-分 s-秒

`public final String format(Date date)`
\- 用于实现Date类型向String类型的转换。

`Date parse(String source)`
\- 用于实现String类型向Date类型的转换。

```java
public class TestSimpleDateFormat {
    public static void main(String[] args) throws Exception{
        //1.使用默认方式构造日期并打印出来
        Date d1 = new Date();
        System.out.println("d1 = " + d1);
        System.out.println("-------------------------------");
        //2.使用SimpleDateFormat类来实现日期输出格式的调整
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        //实现日期类型向文本类型的转换
        String str = sdf.format(d1);
        System.out.println("转换后的日期为：" + str);
        //实现文本类型向日期类型的转换
        Date d2 = sdf.parse(str);
        System.out.println("d2 = " + d2); //原来的格式
    }
}
```

### 5.3 Calendar类

(1)基本概念
`java.util.Calendar`类用于描述特定的瞬间，来取代Date类中的过时方法。
该类是个抽象类，因此该类不能构造对象。

(2)常用的方法
`static Calendar getInstance()`
\- 用于获取Calendar类型的引用并返回。

`void set(int year, int month, int date, int hourOfDay, int minute, int second)`
\- 用于设置年月日时分秒信息。

`Date getTime()`
\- 用于将Calendar类型的时间转换为Date类型的对象并返回。

```java
public class TestCalendar {
    public static void main(String[] args) {
        //1.使用过时的方式按照指定的年月日时分秒来构造对象并打印
        Date d1 = new Date(2008-1900, 8-1, 8, 20, 8, 8);
        //调整一下输出格式
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        System.out.println(sdf.format(d1));
        System.out.println("----------------------------------------");
        //2.使用取代的方式按照指定的年月日时分秒来构造对象并打印
        //2.1 通过静态方法得到Calendar类型的引用
        //思考：既然Calendar类是个抽象类，那么为啥能得到该类的引用呢？？？
        //解析：在方法的内部最终返回的是Calendar类型子类的对象 GregorianCalendar
        //多态的使用场合之三
        Calendar c1 = Calendar.getInstance();
        //2.2 通过set方法来设置年月日时分秒信息
        c1.set(2008, 8-1, 8, 20, 8, 8);
        //2.3 通过getTime()方法转换为Date类型
        Date d2 = c1.getTime();
        //2.4 通过format()方法来调整格式
        System.out.println(sdf.format(d2));
    }
}
```









## 第6 章 Collection类

复习：
当需要在程序中记录单个数据内容时，则声明一个变量即可；
当需要在程序中记录多个类型相同的数据内容时，则声明一个一维数组即可；
当需要在程序中记录多个类型不同的数据内容时，则构造一个对象即可；
当需要在程序中记录多个类型相同的对象时，则声明一个对象数组即可；
当需要在程序中记录多个类型不同的对象时，则声明一个集合即可；
如：
90 => int num = 90;
0、100、59、88、60 => int[] arr = {0, 100, 59, 88, 60};
"zhangsan" 99.5 20 => Student s = new Student("zhangsan", 99.5, 20);
"zhangsan" 99.5 20
"lisi" 59.5 18 => Student[] arr = new Student[2];
"zhangsan" 99.5 20
1, 2, 3, 4 => Collection c1 = new ArrayList();

### 6.1 数组和集合的比较

(1)数组的特点
a.数组本质上就是一段连续的内存空间，一旦创建则内存空间的容量固定不变；
b.支持下标访问，便于实现随机访问；
c.增删元素不方便，可能需要移动大量的元素；
d.元素类型可以是基本数据类型，也可以是引用数据类型；

(2)集合的特点
a.内存空间部分连续部分不连续，容量可以动态调整；
b.部分支持下标访问部分不支持；
c.增删元素可以不移动大量的元素；
d.元素类型必须是引用数据类型，因此需要使用包装类；

### 6.2 集合框架

Java语言中集合框架的顶层接口是：`java.util.Collection` 和 `java.util.Map`。
其中`Collection`接口中存放元素的基本单位是：**单个元素**。
其中`Map`接口中存放元素的基本单位是：**单对元素**。

在以后的开发中很少直接使用Collection接口，而是更多的使用该接口的子接口：List接口、Queue接口以及Set接口。

![Java集合框架图](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20201212165109.jpg)

### 6.3 Collection接口的常用方法

`boolean add(E e)`
\- 用于将参数指定的元素e放入当前集合中。

`boolean addAll(Collection<? extends E> c)`
\- 用于将参数集合c中的所有元素放入当前集合中。

`boolean contains(Object o)`
\- 用于判断当前集合是否包含参数指定的单个元素。

`boolean containsAll(Collection<?> c)`
\- 用于判断是否包含参数c中的所有元素。

`boolean remove(Object o)`
\- 用于将参数指定的单个元素从当前集合删除。

`boolean removeAll(Collection<?> c)`
\- 用于删除参数集合中的所有元素。

`void clear()`
\- 用于清空当前集合中的所有元素。

`int size()`
\- 用于获取集合中的元素个数。

`boolean isEmpty()`
\- 用于判断当前集合是否为空。

`boolean retainAll(Collection<?> c)`
\- 用于计算调用对象和参数对象的交集并保留到当前集合中，覆盖原有数据。
\- 当前集合中的元素若发生改变则返回true，否则返回false。

```java
public class TestCollection {
    public static void main(String[] args) {
        //1.声明Collection类型的引用指向实现类的对象，形成了多态
        Collection c1 = new ArrayList();
        //2.向集合中添加元素并打印
        c1.add("one");
        c1.add(2);
        c1.add(new Student(1001, "zhangfei", 30));
        //[one, 2, Student[id = 1001, name = zhangfei, age = 30]]
        System.out.println("c1 = " + c1); 
        System.out.println("----------------------------------------");
        //3.准备另外一个集合，将集合中的所有元素添加到集合中
        Collection c2 = new ArrayList();
        c2.add(3);
        c2.add("four");
        System.out.println("c2 = " + c2); //c2 = [3, four]
        //将集合c2中的所有元素添加到集合c1中
        c1.addAll(c2);
        //将集合c2整体看做一个元素添加到集合c1中
        //c1.add(c2);
        //[one, 2, Student[id = 1001, name = zhangfei, age = 30], 3, four]
        System.out.println("c1 = " + c1);
        System.out.println("----------------------------------------");
        //4.判断当前集合中是否存在参数指定的单个元素
        boolean b1 = c1.contains(1);
        System.out.println("b1 = " + b1); //false
        b1 = c1.contains(2);
        System.out.println("b1 = " + b1); //true
        //contains方法的执行原理：(o==null ? e==null : o.equals(e))
        //其中o是形参变量，代表要查找的目标元素
        //若查找的目标元素值为null，则在判断当前集合中是否有一个元素为null即可
        //若查找的目标元素不为null，则使用目标元素调用equals()方法与
        //集合中的所有元素依次比较是否相等
        //由于Student类没有重写equals()方法，因此调用从Object继承的方法比较地址false
        //为了比较内容，则应该重写equals()方法
        b1 = c1.contains(new Student(1001, "zhangfei", 30));
        System.out.println("b1 = " + b1); //false true
        System.out.println("----------------------------------------");
        //5.判断参数指定集合中的所有元素是否存在
        //用于判断c1中是否包含c2中的所有元素
        b1 = c1.containsAll(c2);
        System.out.println("b1 = " + b1); //true   false
        //笔试题 用于判断c1中是否包含c2这个元素整体
        b1 = c1.contains(c2);
        System.out.println("b1 = " + b1); //false  true
        System.out.println("----------------------------------------");
        //6.实现集合中元素的删除操作
        //[one, 2, Student[id = 1001, name = zhangfei, age = 30], 3, four]
        System.out.println("c1 = " + c1);
        //实现单个元素的删除操作
        b1 = c1.remove(new Student(1001, "zhangfei", 30));
        System.out.println("b1 = " + b1); //true
        //[one, 2, 3, four]
        System.out.println("c1 = " + c1); 
        //实现多个元素的删除
        b1 = c1.removeAll(c2);
        System.out.println("b1 = " + b1); //true
        System.out.println("c1 = " + c1); //[one, 2]
        //实现清空集合中的所有元素
        c1.clear();
        System.out.println("c1 = " + c1); //c1 = [啥也没有]
        System.out.println("----------------------------------------");
        //7.获取集合中元素的个数以及判断集合是否为空
        System.out.println("集合中元素的个数是：" + c1.size()); //0
        System.out.println(0==c1.size()? "集合已经空了":"集合还没有空"); //空了
        System.out.println(c1.isEmpty()? "集合已经空了":"集合还没有空"); //空了
        System.out.println("----------------------------------------");
        //8.计算集合c1和集合c2中的交集
        System.out.println("c1 = " + c1); //c1 = [啥也没有]
System.out.println("c2 = " + c2); //c2 = [3, four]
//计算集合c2和集合c2的交集，交集的结果还是自己
b1 = c2.retainAll(c2);
        System.out.println("b1 = " + b1); //false
        System.out.println("c2 = " + c2); //c2 = [3, four]
        //计算集合c2和集合c1的交集，交集的结果是 啥也没有
        b1 = c2.retainAll(c1);
        System.out.println("b1 = " + b1); //true
        System.out.println("c2 = " + c2); //c2 = [啥也没有]
    }
}
```







## 第7 章 List集合

### 7.1 基本概念

`java.util.List`接口是`Collection`接口的子接口。
该集合中的所有元素**拥有先后放入次序**，并且**允许重复**。 该集合的主要实现类由：`ArrayList`类`、LinkedList`类以及`Vector`类(过时)。
其中ArrayList类的底层是采用动态数组实现的，因此访问元素方便，增删元素不方便。
其中LinkedList类的底层是采用链表实现的，因此访问元素不方便，增删元素方便。
其中Vector类的底层采用动态数组实现的，该集合与ArrayList类相比属于早期线程安全的类，效率比较低，因此推荐使用ArrayList类。 其中Stack类的底层是采用动态数组实现的，该集合主要用于描述具有后进先出特性的数据结构，叫做栈(last in first out LIFO)

### 7.2 常用的方法(练熟、记住)

`void add(int index, E element)`
\- 用于将元素element插入到下标index的位置。

`boolean addAll(int index, Collection<? extends E> c)`
\- 用于将集合c中的所有元素插入到下标index的位置。

`E get(int index)`
\- 用于根据参数index指定的下标获取对应的元素并返回。

`E remove(int index)`
\- 用于根据参数index指定的下标位置来删除元素。 - 返回被删除的元素值。

`E set(int index, E element)`
\- 用于将参数index指定下标位置的元素修改为element，返回修改之前的元素。

```java
public class TestList {
    public static void main(String[] args) {
        //1.声明List类型的引用指向实现类的对象，形成多态
        List lt1 = new LinkedList();

        //2.向集合中添加元素并打印出来
        lt1.add("one");
        System.out.println("lt1 = " + lt1); //[one]
        //实现向开头位置插入元素：向下标为0的位置插入元素1
        lt1.add(0, 1);
        System.out.println("lt1 = " + lt1); //[1, one]
        //实现向中间位置插入元素
        lt1.add(1, "two");
        System.out.println("lt1 = " + lt1); //[1, two, one]
        //实现向末尾位置插入元素
        lt1.add(lt1.size(), 2);
        System.out.println("lt1 = " + lt1); //[1, two, one, 2]

        System.out.println("--------------------------------------");
        //3.准备另外一个集合，将集合中的所有元素放入集合lt1中
        List lt2 = new LinkedList();
        lt2.add(3);
        lt2.add("three");
        System.out.println("lt2 = " + lt2); //[3, three]
        //向下标为2的位置插入集合lt2中的所有元素
        lt1.addAll(2, lt2);
        //自动调用toString()方法打印结果   String类型的整体
        System.out.println("lt1 = " + lt1); //[1, two, 3, three, one, 2]

        System.out.println("--------------------------------------");
        //4.根据下标获取对应的数据内容并打印出来
        //思考：为啥get方法的返回值类型是Object类型呢？
        //解析：集合中之所以允许存放各种不同类型的对象，是因为将所有对象都看做
        //     Object类型放入的，那么取出来的元素类型也必然是Object类型
        //获取下标为0的元素内容并打印出来
        //为了表达该元素最真实的数据类型，就需要强制类型转换
        Integer it1 = (Integer) lt1.get(0);
        System.out.println("it1 = " + it1); //it1 = 1
        //获取下标为1的元素内容并打印出来
        String str1 = (String)lt1.get(1);
        System.out.println("str1 = " + str1); //str1 = two

        System.out.println("--------------------------------------");
        //若希望将集合中的所有元素获取出来并直接打印
        for(int i = 0; i < lt1.size(); i++){
            //使用get()方法可以将集合中的元素一个个取出来，比toString()更加灵活
            System.out.println("下标" + i + "位置获取到的元素是：" + lt1.get(i));
        }

        System.out.println("--------------------------------------");
        //练习：使用StringBuilder类实现get方法获取所有元素的结果与toString相同
        StringBuilder sb1 = new StringBuilder();
        sb1.append("[");
        //使用for循环获取集合中的所有元素，拼接到倒数第二个元素即可
        /*
        for(int i = 0; i < lt1.size()-1; i++){
            sb1.append(lt1.get(i)).append(",").append(" ");
        }
        //最后一个元素的后面没有逗号加空格，而是]
        sb1.append(lt1.get(lt1.size()-1)).append("]");
        */
        //拼接到最后一个元素
        for(int i = 0; i < lt1.size(); i++){
            sb1.append(lt1.get(i)).append(",").append(" ");
        }
        sb1.delete(sb1.length()-2, sb1.length()).append("]");
        System.out.println("lt1 = " + sb1);

        System.out.println("--------------------------------------");
        //5.根据下标来删除指定的元素
        System.out.println("lt1 = " + lt1); //[1, two, 3, three, one, 2]
        //删除下标为0的元素并打印出来
        Integer it2 = (Integer) lt1.remove(0);
        System.out.println("被删除的元素是：" + it2); //1
        System.out.println("删除之后集合的元素有：" + lt1); 
        //[two, 3, three, one, 2]
        //删除下标为3的元素并打印出来
        String str2 = (String) lt1.remove(3);
        System.out.println("被删除的元素是：" + str2); //one
        System.out.println("删除之后集合的元素有：" + lt1);//[two, 3, three, 2]

        System.out.println("--------------------------------------");
        //实现将所有元素删除    4 3 2
        //for(int i = 0; i < lt1.size(); /*i++*/){
        //  System.out.println("被删除的元素是：" + lt1.remove(i));
        //}
        /*
        for(int i = lt1.size()-1; i >= 0; i--){
            System.out.println("被删除的元素是：" + lt1.remove(i));
        }
        System.out.println("删除之后集合的元素有：" + lt1); //啥也没有
        */
        System.out.println("--------------------------------------");
        //6.实现元素的修改/替换功能
        System.out.println("lt1 = " + lt1); //[two, 3, three, 2]
        //实现将集合中元素3修改为"three"
        Integer it3 = (Integer) lt1.set(1, "three");
        System.out.println("被替换的元素是：" + it3); //3
        System.out.println("lt1 = " + lt1); //[two, three, three, 2]
        //实现将集合中元素2修改为"two"
        Integer it4 = (Integer)lt1.set(3, "two");
        //每次调用方法时需要严格核对被替换元素的数据类型，否则很容易发生异常
        //对代码的编写带来很多的困难
        //String str3 = (String)lt1.set(3, "two"); //发生类型转换异常
        System.out.println("被替换的元素是：" + it4); //2
        System.out.println("lt1 = " + lt1); //[two, three, three, two]

        System.out.println("--------------------------------------");
        //7.获取List集合中的一部分内容，包含1但不包含4
        List lt3 = lt1.subList(1, 4);
        System.out.println("lt3 = " + lt3); //[three, three, two]
        //修改子链表中的内容
        String str4 = (String) lt3.set(0, 3);
        System.out.println("str4 = " + str4); //three
        System.out.println("lt3 = " + lt3); //[3, three, two]
        System.out.println("lt1 = " + lt1); //[two, 3, three, two]
    }
}   
```

### 7.3 泛型机制

通常情况下集合中允许存放各种不同类型的对象，此时这些对象都被看做Object类型放入，当集合中的这些数据被取出之后也是Object类型，为了表达数据的真实类型需要做强制类型转换，而强制类型转换很可能引发类型转换异常。
为了避免上述问题的发生，从jdk1.5开始提出泛型机制，要求在集合名称的右边使用<数据类型>的方式明确要求该集合可以存放的元素类型，若放入其他类型数据则编译报错。
如：
List lt1 = new LinkedList();
\- 元素类型只能是String类型

泛型的本质就是参数化类型，也就是让数据类型作为参数传递的方式，其中E相当于形式参数负责占位，当准备集合时<>中的数据类型相当于实际参数负责给形式参数E进行赋值，此时集合中所有E都被替换为实际参数类型，由于实际参数可以传递的类型非常广泛，因此得名"泛型"
如：

```java
//其中i叫做形式参数，负责占位          其中E叫做形式参数，负责占位
//int i = 3;                           E = String;
//int i = 5;                           E = Integer;
public void show(int i){               public interface List<E>{
   ...                                      ...
}                                      }

//其中3叫做实际参数，负责给形参赋值    其中String叫做实际参数，负责给形参赋值
show(3);                               List<String> lt1 = ...;
show(5);                               List<Integer> lt2 = ...;

public class TestListType {
    public static void main(String[] args) {
        //1.使用泛型机制准备一个集合
        List<String> lt1 = new LinkedList<String>();
        //向集合中添加元素
        lt1.add("one");
        //lt1.add(2); error
        System.out.println("lt1 = " + lt1); //[one]
        System.out.println("----------------------------------");
        //2.从集合中取出元素
        String str1 = lt1.get(0);
        System.out.println("获取到的元素是：" + str1);
        System.out.println("----------------------------------");
        //集合中元素的类型是Integer
        List<Integer> lt2 = new LinkedList<Integer>();
        //元素类型为Student
        List<Student> lt3 = new LinkedList<Student>();
        //从jdk1.7开始增加新特性：后面<>中的数据类型可以省略  叫做菱形特性
        List<Student> lt4 = new LinkedList<>();
    }
}
```







## 第8 章 Queue集合

### 8.1 基本概念

`java.util.Queue`接口是`Collection`接口的子接口，与`List`接口是平级关系。
该接口主要用于描述具有先进先出特性的数据结构，叫做队列(FIFO first in first out)
**该接口的主要实现类是：`LinkedList`，该类在增删方面有一定的优势。**

### 8.2 常用的方法

`boolean offer(E e)` - 用于将参数指定的元素e插入当前队列。

`E poll()` - 用于获取并移除队列的队首元素，若队列为空则返回null。

`E peek()` - 用于获取队列的队首元素，若队列为空则返回null。

```java
public class TestQueue {
    public static void main(String[] args) {
        //1.声明Queue接口类型的引用指向实现类的对象
        Queue<Integer> q1 = new LinkedList<Integer>();
        //2.将元素11 22 33 44 55依次进行入队操作并打印
        for(int i = 1; i <= 5; i++){
            boolean b1 = q1.offer(new Integer(i*11));
            //System.out.println("b1 = " + b1); //true
            //自动调用toString()
            System.out.println("队列中的元素有：" + q1); //11 22 33 44 55
        }
        System.out.println("----------------------------------------");
        //3.查看队列中队首元素值并打印
        System.out.println("队首元素是：" + q1.peek()); //11
        System.out.println("----------------------------------------");
        //4.将队列中的所有元素依次进行出队操作并打印
        int len = q1.size();
        for(int i = 1; i <= len; i++){
            System.out.println("出队的元素是：" + q1.poll());//11 22 33 44 55
        }
        System.out.println("----------------------------------------");
        //5.查看出队之后的结果
        System.out.println("最终队列的元素有：" + q1); //[啥也没有]
    }
} 
```







## 第9 章 Set集合

### 9.1 基本概念

`java.util.Set`接口是`Collection`接口的子接口，与`List`接口是平级关系。
该接口与List接口相比**元素没有先后次序**，并且**不允许有重复的元素**。
**该接口的主要实现类：HashSet类 和 TreeSet类。**
其中`HashSet`类的底层是采用哈希表进行数据管理的。
其中`TreeSet`类的底层是采用有序二叉树进行数据管理的。

### 9.2 迭代器

参考Collection集合即可。
`Iterator iterator()` - 获取当前集合中的迭代器对象，用于迭代/遍历集合中所有元素
其中Iterator是个接口，常用方法如下：
`boolean hasNext()`
\- 用于判断是否拥有可以访问的元素。

`E next()`
\- 用于取出一个元素并指向下一个位置。

`void remove()`
\- 用于将刚刚取出的元素删除。

注意：
当使用迭代器访问元素时不允许调用集合的方法删除元素，否则会发生`ConcurrentModificationException`并发修改异常。

```java
public class TestSet {
    public static void main(String[] args) {
        // 1.声明Set接口的引用指向实现类的对象，形成了多态
        Set<String> s1 = new HashSet<String>();
        // 2.向集合中添加元素内容
        boolean b1 = s1.add("two");
        System.out.println("b1 = " + b1); // true
        System.out.println("s1 = " + s1); // [one, two]
        b1 = s1.add("one");
        System.out.println("b1 = " + b1); // true
        System.out.println("s1 = " + s1); // [one]
        b1 = s1.add("three");
        System.out.println("b1 = " + b1); // true
        System.out.println("s1 = " + s1); // [one, two, three]
        b1 = s1.add("one");
        System.out.println("b1 = " + b1); // false
        // 自动调用toString()方法，得到String类型的整体
        System.out.println("s1 = " + s1); // [one, two, three]
        System.out.println("-------------------------");
        // 3.使用迭代器来访问集合中的每个元素并打印出来
        // 3.1 获取迭代器对象并记录
        Iterator<String> it1 = s1.iterator();
        /*
        // 3.2 判断是否拥有可以访问的元素
        System.out.println(it1.hasNext()); // true
        // 3.3 取出该元素并并打印出来然后指向下一个位置
        System.out.println("获取到的元素是：" + it1.next()); // one
        // 3.2 判断是否拥有可以访问的元素
        System.out.println(it1.hasNext()); // true
        // 3.3 取出该元素并并打印出来然后指向下一个位置
        System.out.println("获取到的元素是：" + it1.next()); // two
        */
        while(it1.hasNext()){
            System.out.println("获取到的元素是：" + it1.next()); //one two three
        }
        System.out.println("-------------------------");
        //练习：使用StringBuilder类和迭代器实现toString()方法的打印效果
        StringBuilder sb1 = new StringBuilder();
        sb1.append("[");
        //重新获取迭代器，也就是让迭代器回到开头位置
        it1 = s1.iterator();
        //将集合中每个元素取出来拼接字符串
        while(it1.hasNext()){
            String str = it1.next();
            //若处理最后一个元素时，直接连接元素和]
            /*
            if(!it1.hasNext()){
                sb1.append(str).append("]");
            }else{
                sb1.append(str).append(",").append(" ");
            }
            */
            if(it1.hasNext()){
                sb1.append(str).append(",").append(" ");
            }else{
                sb1.append(str).append("]");
            }
        }
        //将最后一个元素后面的逗号和空格删除
        //sb1.delete(sb1.length()-2, sb1.length());
        //拼接最后的]
        //sb1.append("]");
        System.out.println("s1 = " + sb1);

        System.out.println("-------------------------");
        //4.实现集合中元素的删除操作
        System.out.println("s1 = " + s1); //[one, two, three]
        //使用迭代器获取集合中的每个元素并判断，若是"two"则删除否则打印即可
        //重新获取迭代器，也就是让迭代器回到开头位置
        it1 = s1.iterator();
        while(it1.hasNext()){
            //切记next()方法会取出元素的同时指向下一个位置
            /*
            if(it1.next().equals("two")){
                //调用迭代器的remove()方法可以删除元素
                it1.remove();
            }else{
                System.out.println(it1.next());
            }
            */
            String str2 = it1.next();
            if("two".equals(str2)){
                //调用迭代器自己的remove()方法删除元素
                it1.remove();
                //调用Set集合自己的remove()方法删除元素
                //s1.remove(str2); //编译ok，运行产生异常
            }else{
                System.out.println(str2); 
            }
        }   
        System.out.println("-------------------------");
        System.out.println("删除之后的结果是：" + s1); //[one, three]
        System.out.println("-------------------------");
        //5.使用增强版的for循环来打印集合s1中的所有元素，推荐使用
        for(String ts : s1){
            System.out.println(ts);
        }
        System.out.println("-------------------------");
        //使用增强版的for循环打印数组中的所有元素
        int[] arr = {11, 22, 33, 44, 55};
        for(int ti : arr){
            System.out.println(ti);
        }
    }
}
```

### 9.3 元素放入HashSet集合的原理(理解)

(1)使用新元素调用hashCode()方法得到该元素的哈希码值；
(2)将哈希码值交给哈希算法算出新元素在哈希表数组的索引位置；
(3)若该位置没有元素，则直接将新元素放入即可；
(4)若该位置有元素，则使用新元素与已有元素依次比较；
(5)若新元素与已有元素相等，则放弃新元素的插入保留旧元素；
(6)若新元素与已有元素都不相等，则将新元素放入所有已有元素的后面；

提问：
为啥要保持equals()方法和hashCode()方法的一致性呢？？？
解析：
为了确保相同数值的内容调用equals()方法的结果相等，此时各自调用hashCode()方法的结果相同，此时交由同样的哈希算法算出的索引位置相同，减少比较的次数从而提高性能。

### 9.4 增强版的for循环(for each)

(1)语法格式

```java
for(元素类型 变量名 : 集合/数组的名称){  
    循环体;  
}
```

(2)执行流程
不断地从集合/数组中取出一个元素赋值给变量后执行循环体，直到处理完毕所有元素为止

总结：
对于Set集合来说遍历所有元素的方式有：toString()、迭代器、for each。
对于List集合来说遍历所有元素的方式有：除了上述三种方式外，还有get()方法。

### 9.5 TreeSet类

(1)什么是二叉树？
二叉树就是指每个节点最多只有两个子节点的树形结构。

(2)什么是有序二叉树？
满足以下3个条件的二叉树就叫做有序二叉树，具体如下：
a.要求左子树中任意节点都小于根节点；
b.要求右子树中任意节点都大于根节点；
c.要求左子树和右子树的内部也要遵守上述要求；

(3)元素放入TreeSet集合的原理
由于TreeSet集合的底层是采用有序二叉树实现的，当插入新元素到TreeSet集合时需要比较新元素与已有元素的大小来确定新元素的位置，从而保证二叉树依然有序，而比较方式有两种
a.使用元素的自然排序规则比较，也就是让元素类型实现`java.lang.Comparable`接口；
b.使用比较器规则比较，也就是创建TreeSet集合时传入`java.util.Comparator`接口；

注意：
使用TreeSet集合时默认采用自然排序规则处理，但自然排序规则只能按照一种规则排序，若希望可以多元化排序，则借助比较器处理。

```java
public class Student implements Comparable<Student>{
    @Override
    public int compareTo(Student o) {
        //表示调用对象和参数对象相等，其中调用对象指新增加的元素，参数对象指已有元素
        //return 0;
        //表示调用对象大于参数对象，也就是新增加的元素大
        //return 1;
        //表示调用对象小于参数对象，也就是新增加的元素小
        //return -1;
        //表示按照学号进行排序
        //return this.getId() - o.getId();
        //表示按照姓名进行排序
        //return this.getName().compareTo(o.getName());
        //表示按照年龄进行排序
        //return this.getAge() - o.getAge();
        //表示先按照学号排序，若学号相同则按照姓名排序
        int num = this.getId() - o.getId();
        return num != 0? num: this.getName().compareTo(o.getName());
    }
}
```

测试：

```java
public class TestTreeSet {
    public static void main(String[] args) {
        // 1.声明Set接口的引用指向实现类的对象，形成多态
        Set<String> s1 = new TreeSet<String>();
        // 2.向集合中添加元素并打印
        boolean b1 = s1.add(new String("zhousiyu"));
        System.out.println("b1 = " + b1); // b1 = true
        System.out.println("s1 = " + s1); // [zhousiyu]
        b1 = s1.add(new String("wangdongsheng"));
        System.out.println("b1 = " + b1); // b1 = true
        System.out.println("s1 = " + s1); // [wangdongsheng, zhousiyu]

        System.out.println("--------------------------------------");
        // 3.准备另外一个集合放入Student类型的对象，默认从小到大排序
        Set<Student> s2 = new TreeSet<Student>();
        // 添加元素
        s2.add(new Student(1003, "zhaoyun", 25));
        s2.add(new Student(1001, "zhangfei", 30));
        s2.add(new Student(1005, "machao", 18));
        s2.add(new Student(1002, "guanyu", 35));
        s2.add(new Student(1004, "huangzhong", 40));
        // 使用增强版的for循环打印所有元素
        for (Student ts : s2) {
            System.out.println(ts);
        }

        System.out.println("--------------------------------------");
        // 4.使用比较器来指定比较的规则
        // 接口/父类类型 引用变量名 = new 接口/父类类型(){ 方法的重写 };
        Comparator<Student> c1 = new Comparator<Student>() {
            // o1代表新增加的元素, o2代表集合中已有的元素
            @Override
            public int compare(Student o1, Student o2) {
                // 按照学号大小进行排序
                return o1.getId() - o2.getId();
            }
        };
        Comparator<Student> c2 = new Comparator<Student>() {
            // o1代表新增加的元素, o2代表集合中已有的元素
            @Override
            public int compare(Student o1, Student o2) {
                // 按照姓名大小进行排序
                return o1.getName().compareTo(o2.getName());
            }
        };
        Comparator<Student> c3 = new Comparator<Student>() {
            // o1代表新增加的元素, o2代表集合中已有的元素
            @Override
            public int compare(Student o1, Student o2) {
                // 按照年龄大小进行排序
                return o1.getAge() - o2.getAge();
            }
        };
        // 表示该集合按照c1指定的规则来比较元素的大小
        Set<Student> s3 = new TreeSet<Student>(c3);
        // 添加元素
        s3.add(new Student(1003, "zhaoyun", 25));
        s3.add(new Student(1001, "zhangfei", 30));
        s3.add(new Student(1005, "machao", 18));
        s3.add(new Student(1002, "guanyu", 35));
        s3.add(new Student(1004, "huangzhong", 40));
        // 使用增强版的for循环打印所有元素
        for (Student ts : s3) {
            System.out.println(ts);
        }
    }
}
```







## 第10 章 Map集合

### 10.1 基本概念

`java.util.Map<K,V>`接口中存放元素的基本单位是：单对元素。
K - 用于描述键(Key)的类型。
V - 用于描述值(Value)的类型。
**该接口的主要实现类：HashMap类 和 TreeMap类。**
该接口中key(键)不允许重复，而且每个key(键)只能对应一个Value(值)。
(面试题)HashMap和HashTable区别
答：线程安全和线程不安全
(面试题)HashMap和Hashset关系 答：HashSet的实现是基于HashMap

```java
public class TestMap {
    public static void main(String[] args) {
        //1.声明Map类型的引用指向实现类的对象
        Map<Integer, String> m1 = new HashMap<Integer, String>();
        //2.向集合中添加元素
        String str1 = m1.put(1, "one");
        System.out.println("str1 = " + str1); //null
        //自动调用toString()，调用HashMap中的toString()方法
        //默认打印格式为：{键1=值1, 键2=值2, ...}
        System.out.println("m1 = " + m1); //{1=one}
        //增加
        str1 = m1.put(2, "two");
        System.out.println("str1 = " + str1); //null
        System.out.println("m1 = " + m1); //{1=one, 2=two}
        //增加
        str1 = m1.put(3, "three");
        System.out.println("str1 = " + str1); //null
        System.out.println("m1 = " + m1); //{1=one, 2=two, 3=three}
        //修改
        str1 = m1.put(1, "eleven");
        System.out.println("str1 = " + str1); //one
        System.out.println("m1 = " + m1); //{1=eleven, 2=two, 3=three}
    }
}
```

### 10.2 常用的方法

`V put(K key, V value)`
\- 用于将key和value组成一对放入当前集合中。
\- 若实现增加功能则返回null；若实现修改功能则返回原来的value.

`boolean containsKey(Object key)`
\- 用于判断当前集合中是否存在参数指定的key。

`boolean containsValue(Object value)`
\- 用于判断当前集合中是否存在参数指定的value。

`V get(Object key)`
\- 用于根据参数指定的key返回对应的value，若key不存在则返回null。

`V remove(Object key)`
\- 用于根据参数指定的key来删除键值对，返回该key对应的value。

`Set<Map.Entry<K,V>> entrySet()`
\- 用于将Map集合转换为Set集合，集合中的每个元素都是键值对。
\- 其中Map.Entry是接口类型，常用方法有：
K getKey() - 用于获取键值对中的键。
V getValue() - 用于获取键值对中的值。

`Set keySet()`
\- 用于将Map集合中的所有键放入Set集合中并返回。

```java
public class TestHashMap {
    public static void main(String[] args) {
        //1.声明Map类型的引用指向实现类的对象，形成多态
        Map<String, String> m1 = new HashMap<String, String>();

        //2.向Map集合中添加元素并打印
        m1.put("1", "one");
        m1.put("2", "two");
        m1.put("3", "three");
        System.out.println("m1 = " + m1); //{1=one, 2=two, 3=three}

        System.out.println("--------------------------------------");
        //3.查找Map集合中是否拥有指定的key以及指定的value并打印
        boolean b1 = m1.containsKey("4");
        System.out.println("b1 = " + b1); //false
        b1 = m1.containsKey("1");
        System.out.println("b1 = " + b1); //true

        b1 = m1.containsValue("eleven");
        System.out.println("b1 = " + b1); //false
        b1 = m1.containsValue("three");
        System.out.println("b1 = " + b1); //true

        System.out.println("--------------------------------------");
        //4.根据参数指定的key返回对应的value，若不存在则返回null
        String str1 = m1.get("5");
        System.out.println("str1 = " + str1); //null
        str1 = m1.get("2");
        System.out.println("str1 = " + str1); //two

        System.out.println("--------------------------------------");
        //5.实现集合中元素的删除
        String str2 = m1.remove("10");
        System.out.println("str2 = " + str2); //null
        System.out.println("m1 = " + m1); //{1=one, 2=two, 3=three}

        str2 = m1.remove("1");
        System.out.println("str2 = " + str2); //one
        System.out.println("m1 = " + m1); //{2=two, 3=three}

        System.out.println("--------------------------------------");
        //6.实现Map集合中所有元素的遍历
        //方式一：调用toString()方法可以实现遍历
        System.out.println("m1 = " + m1); //{2=two, 3=three}

        System.out.println("----------------------------------");
        //方式二：调用entrySet()方法可以实现遍历
        //实现Map集合向Set集合的转换
        Set<Map.Entry<String,String>> s1 = m1.entrySet();
        //使用for each结构来打印Set集合中的所有元素
        for(Map.Entry<String,String> me : s1){
            //System.out.println(me);
            System.out.println(me.getKey() + "=" + me.getValue());
        }

        System.out.println("----------------------------------");
        //方式三：调用keySet()方法可以实现遍历
        //实现Map集合中所有的key转换为Set集合
        Set<String> s2 = m1.keySet();
        //使用for each结构打印Set集合中的所有元素
        for(String ts : s2){
            System.out.println(ts + "=" + m1.get(ts));
        }
    }
}  
```

练习：使用HashMap集合统计字符串"123,456,789,123,456"中每个数字字符串出现的次数并打印

```java
public class TestHashMapCnt {
    public static void main(String[] args) {

        //1.准备Map类型的引用指向HashMap类型的对象，形成多态
        Map<String, Integer> m1 = new HashMap<String, Integer>();

        //2.拆分字符串"123,456,789,123,456"中的每个数字字符串并将次数统计到集合中
        String str1 = "123,456,789,123,456";
        //按照逗号拆分字符串中的每个数字字符串并打印出来
        String[] sArr = str1.split(",");
        //使用for each结构来打印数组中的每个元素
        for(String ts : sArr){
            System.out.println(ts);
            //将拆分出来的每个字符串作为key放入集合，并将次数作为value放入集合
            //若该字符串内容在集合中不存在，则将该字符串和1组成一对放入集合中
            if(!m1.containsKey(ts)){
                m1.put(ts, 1);
            }
            //若该字符串内容在集合中存在，则将原来的value取出来加1再放进去
            else{
                m1.put(ts, m1.get(ts)+1);
            }
        }
        //3.打印最终的统计结果
        System.out.println("m1 = " + m1);
    }
}
```







## 第11 章 异常机制

### 11.1 基本概念

异常就是"不正常"的含义，在Java语言中主要指运行阶段发生的错误。
`java.lang.Throwable`类是Java语言中错误(Error类) 和 异常(Exception类)的超类。
其中`Error`类主要描述比较严重通常无法编码解决的错误，如：Java虚拟机挂了。
其中`Exception`类主要描述轻微可以编码解决的错误，如：0作为除数。

### 11.2 异常的分类

`java.lang.Exception`类是所有异常的超类，具体分类如下：
`RuntimeException`异常 - 运行时异常，也叫做非检测性异常。
`IOException`和其它异常 - 其他异常，也叫做检测性异常。
\- 所谓检测性异常就是在编译阶段能够被编译器检测出来并给出提示的异常。
`RuntimeException`异常的主要子类：
`ArithmeticException `- 算术异常
`ArrayIndexOutOfBoundsException` - 数组下标越界异常
`NullPointerException` - 空指针异常
`ClassCastException` - 类型转换异常
`NumberFormatException` - 数字格式异常

```java
public class TestException {
    public static void main(String[] args) {
        //1.见识一下非检测性异常
        int ia = 10;
        int ib = 0;
        System.out.println(ia/ib);
        //2.见识一下检测性异常
        //Thread.sleep(1000);
        System.out.println("程序结束了");
    }
}
```

注意：
当程序执行过程中发生异常又没有手动处理时，则由Java虚拟机采用默认方式处理，而默认处理方式：打印异常的名称、异常的原因、异常发生位置后终止程序，导致后续代码无法执行

### 11.3 异常的避免

对于绝大多数的非检测性异常可以直接使用if条件判断来避免该异常的发生。

```java
public class TestExceptionPrevent {
    public static void main(String[] args) {
        //故意发生一下算术异常
        int ia = 10;
        int ib = 0;
        if(ib != 0){
            System.out.println(ia / ib);
        }

        //故意发生一下数组下标越界异常
        int[] arr = new int[5];
        int pos = 5;
        if(pos >= 0 && pos < 5){
            System.out.println(arr[pos]);
        }

        //故意发生一下空指针异常
        String str1 = null;
        if(null != str1){
            System.out.println(str1.length());
        }

        //故意发生类型转换异常
        Exception ex = new Exception();
        if(ex instanceof IOException){
            IOException ie = (IOException)ex;
        }

        //故意发生数字格式异常
        String str2 = "123abc";
        if(str2.matches("\\d+")){
            System.out.println(Integer.parseInt(str2));
        }

        System.out.println("异常总算避免了！！！");
    }
}
```

### 11.4 异常的捕获

(1)语法格式

```java
   try{
      编写所有可能发生异常的语句；
   }   
   catch(异常类型 变量名){
      编写针对该类异常处理的语句；
   }
   ...
   finally{
      编写无论是否发生异常都应该执行的语句；
   }
```

案例：

```java
public class TestExceptionCatch {
    public static void main(String[] args) {
        //构造对象与c:/a.txt文件关联
        FileInputStream fis = null;
        try {
            System.out.println("1");
            fis = new FileInputStream("c:/a.txt");
            System.out.println("2");
        } catch (FileNotFoundException e) {
            System.out.println("3");
            e.printStackTrace();
            System.out.println("4");
        }
        //断开关联
        try {
            System.out.println("5");
            fis.close();
            System.out.println("6");
        }  catch(Exception e){
            e.printStackTrace();
        }  /*catch (IOException e) {
            System.out.println("7");
            e.printStackTrace();
            System.out.println("8");
        //拥有下面的catch分支之后可以让程序继续向下执行
        } catch(NullPointerException e){ 
            e.printStackTrace();
        }*/
        //当文件存在时的执行流程：1  2  5  6  世界上...
        //当文件不存在并没有处理空指针异常时的执行流程：1 3 4 5  空指针异常导致程序终止
        //当文件不存在并处理空指针异常时的执行流程：1 3 4 5 世界上...
    }
}
```

(2)注意事项
a.若需要多个catch分支时，切记小类型的异常放在大类型的前面。
b.懒人的写法：
catch(Exception e){ ...}
c.finally{}中的代码主要用于进行善后工作的处理，如：关闭打开的文件、删除文件等

```java
public class TestExceptionFinally {
    public static void main(String[] args) {
        //数据库连接...
        try{
            int ia = 10;
            int ib = 0;
            System.out.println(ia / ib);
        }catch(Exception e){
            e.printStackTrace();
            return; //用于返回数据并结束当前方法，没有返回值时return专门用于结束方法
        }finally{
            //数据库连接关闭...
            System.out.println("无论是否发生异常都记录来执行我这里的代码哦！");
        }
        System.out.println("程序结束了！");
    }
}     
```

### 11.5 异常的抛出

(1)基本概念
在某些特殊场合中无法处理或不便于处理发生的异常，此时就需要将异常转移给该方法的调用者处理，这种方式就叫异常的抛出。

(2)语法格式
访问控制符 返回值类型 方法名称(形参列表) throws 异常类型1,异常类型2,...{}

```java
public class TestExceptionThrows {
    public static void main(String[] args) throws IOException {
        //在以后的开发中不建议将main()方法中的异常抛出
        FileInputStream fis = new FileInputStream("c:/a.txt");
        fis.close();
    }
}
```

(3)方法重写的原则
a.要求方法名相同、参数列表相同、返回值类型相同，从jdk1.5开始允许返回子类。
b.要求方法权限不能变小，可以相同或变大。
c.要求不能抛出更大的异常。

```java
public class TestExceptionA {
    public void show() throws IOException{}
}
public class TestSubExceptionA extends TestExceptionA {
    //public void show() throws Exception{}  抛出更大的异常 error
    //public void show() throws ApplicationException{} 抛出平级不一样的异常  error
    //public void show() throws IOException{}  抛出一样的异常 ok
    //public void show() throws FileNotFoundException{} 抛出更小的异常 ok
    public void show(){} //不抛出异常  ok
}
```

注意：
子类重写的方法可以抛出与父类一样的异常、更小的异常以及不抛出异常，但不能抛出更大的异常或平级不一样的异常。

### 11.6 自定义异常

(1)基本概念
虽然Java官方提供了大量异常类但没有专门针对年龄不合理的异常类，若希望使用这种针对性的异常就需要程序员自己写一个异常类。

(2)实现流程
a.自定义XXXException继承Exception或者其子类；
b.提供两个版本的构造方法：无参构造 和 字符串作为参数的构造；
案例：

```java
public class AgeException extends Exception {
    private static final long serialVersionUID = 1L;
    public AgeException(){
    }
    public AgeException(String msg){
        super(msg);
    }
    //练习：自定义Person类实现封装，特征有：姓名和年龄，要求重写toString()方法
    //      自定义TestPerson类，在main()方法创建对象并打印所有特征。
}
```

练习：

```java
public class Person {
    private String name;
    private int age;

    public Person() {
        super();
    }
    public Person(String name, int age) throws AgeException {
        super();
        setName(name);
        setAge(age);
    }

    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) throws AgeException {
        if(age > 0 && age < 150){
            this.age = age;
        }else{
            //System.out.println("年龄不合理！！！");
            //当年龄不合理时产生异常对象
            //throw new NullPointerException();
            throw new AgeException("年龄不合理！！！");
        }
    }
    @Override
    public String toString() {
        return "Person [name=" + name + ", age=" + age + "]";
    }
}
```

测试类：

```java
public class TestPerson {
    public static void main(String[] args) {
        Person p = null;
        try {
            p = new Person("zhangfei", -30);
        } catch (AgeException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        System.out.println("p = " + p);
    }
}
```

(3)异常对象的产生
throw new 异常类型();
如：
throw new NullPointerException(); - 表示产生空指针异常
**(面试题)throws和throw的区别**







## 第12 章 File类

### 12.1 基本概念

`java.io.File`类**主要用于描述文件和目录的路径信息，可以获取文件的大小等特征**。

### 12.2 常用的方法

`File(String pathname)` - 根据参数指定的路径名来构造对象。

`boolean exists()` - 用于判断文件或目录是否存在。

`String getName()` - 用于获取文件或目录的名称。

`long length()` - 用于获取文件的长度/大小。

`long lastModified()`
\- 用于获取最后一次修改时间。
\- 返回最后一次修改时间距离1970年1月1日0时0分0秒的毫秒数
\- 通常与Date类有参构造方法搭配使用。

`String getAbsolutePath()` - 用于获取绝对路径信息。

```java
   绝对路径：主要指以根目录开始的路径信息，如：c:/...  d:/...   /...
   相对路径：主要指以当前工作目录开始的路径信息，如：./...
             . - 代表当前目录    .. - 代表当前目录的上一级目录。
   在以后的开发中都采用相对路径信息。
```

`boolean delete()`
\- 用于删除文件或目录。
\- 若删除的是目录，则要求该目录必须为空。

`boolean createNewFile()` - 用于创建新的空文件。

`boolean mkdir()` - 用于创建单层目录。

`boolean mkdirs()` - 用于创建多层目录。

`File[] listFiles()` - 用于获取当前目录中的所有内容。

`boolean isFile()` - 用于判断是否为一个标准文件。

`boolean isDirectory()` - 用于判断是否为一个目录。

```java
public class TestFile {
    public static void main(String[] args) throws IOException {
        //1.创建File类型的对象与c:/a.txt文件关联
        File f1 = new File("c:/a.txt");
        //2.判断文件是否存在，若存在则获取相关信息打印后删除该文件
        if(f1.exists()){
            System.out.println("文件名称：" + f1.getName());
            System.out.println("文件大小：" + f1.length());
            Date d1 = new Date(f1.lastModified());
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            System.out.println("文件最后一次修改时间：" + sdf.format(d1));
            System.out.println("文件绝对路径信息：" + f1.getAbsolutePath());
            //打印完毕所有信息后删除该文件
            System.out.println(f1.delete()?"删除文件成功!":"删除文件失败！");
        }
        //3.若文件不存在，则创建新的空文件
        else{
            System.out.println(f1.createNewFile()?"创建文件成功":"创建文件失败");
        }
        System.out.println("-------------------------------------------");
        //4.实现目录的创建和删除
        File f2 = new File("c:/捣乱/猜猜我是谁/就不告诉你/死鬼");
        if(f2.exists()){
            System.out.println(f2.delete()?"删除目录成功":"删除目录失败");
        }else{
            //System.out.println(f2.mkdir()?"创建目录成功":"创建目录失败");
            System.out.println(f2.mkdirs()?"创建目录成功":"创建目录失败");
        }
        System.out.println("-------------------------------------------");
        //5.实现目录中所有内容的获取并打印出来
        File f3 = new File("D:\\java24\\day15");
        //获取目录中的所有内容并返回
        File[] fArr = f3.listFiles();
        //遍历数组中的所有内容
        for(File tf : fArr){
            if(tf.isFile()){
                System.out.println(tf.getName());
            }
            if(tf.isDirectory()){
                System.out.println("[" + tf.getName() + "]");
            }
        }
    }
}    
```







## 第12 章I/O流

### 12.1 基本概念

I/O就是Input/Output的简写，也就是输入/输出的含义。
I/O流就是指像流水一样不间断地进行读写数据的状态。

### 12.2 基本分类

按照数据读写的单位不同分为：字节流 和 字符流。
其中字节流主要指以字节为单位进行读写的过程，可以读写任意类型的文件。
其中字符流主要指以字符(2个字节)为单位进行读写的过程，只能读写文本文件。

按照数据流动的方向不同分为：输入流 和 输出流(站在程序的角度)。
其中输入流主要指从文件中读取数据内容输入到程序中。
其中输出流主要指将程序中的数据内容输出到文件中，也就是写入文件。

### 12.3 基本框架

字节流的顶层父类：`InputStream`类 和 `OutputStream`类 - 抽象类
其中`InputStream`类的常用子类：
`FileInputStream`类、`DataInputStream`类、`ObjectInputStream`类
其中`OutputStream`类的常用子类：
`FileOutputStream`类、`DataOutputStream`类、`ObjectOutputStream`类

字符流的顶层父类：`Reader`类 和 `Writer`类 - 抽象类
其中`Reader`类的常用子类：
`BufferedReader`类、`InputStreamReader`类
其中`Write`r类的常用子类：
`BufferedWriter类`、`OutputStreamWriter`类

补充：
**`java.io.PrintStream`类是`OutputStream`类的间接子类**。

![JavaIO流框架图](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20201212165153.png)

### 12.4 FileOutputStream类(重中之重)

(1)基本概念
`java.io.FileOutputStream`类主要用于写入图像数据之类的原始字节流到输出流中。

(2)常用的方法
`FileOutputStream(String name)`
\- 根据参数指定的文件名来构造对象。

`FileOutputStream(String name, boolean append)`
\- 以追加的方式根据文件名构造对象。

`void write(int b)`
\- 用于将参数指定的单个字节写入输出流。

`void write(byte[] b, int off, int len)`
\- 用于将数组b中下标从off开始的len个字节写入输出流。

`void write(byte[] b)`
\- 用于将数组b中所有字节写入输出流。

`void close()`
\- 用于关闭流并释放有关的资源。

```java
public class TestFileOutputStream {
    public static void main(String[] args) {
        try{
            //1.构造FileOutputStream类型的对象与c:/a.txt文件关联
            //当文件不存在时，该流会自动创建新的空文件
            //当文件存在时，该流会清空文件中的原有内容
            FileOutputStream fos = new FileOutputStream("c:/a.txt");
            //当文件存在时，该流不会清空原有内容，而是将新内容写入文件的末尾
            //FileOutputStream fos = new FileOutputStream("c:/a.txt", true);
            //2.写入数据到输出流中
            //写入的数据是65，由于a.txt是个文本文件，因此会将写入数据按照文本解析
            //65 => 'A'
            fos.write(65);
            //上面写入整数数据65，到了文本文件需要翻译为文本
            //下面写入的就是文本数据字符'6'，到了文本文件还是字符'6'
            //每当写入一个字节的数据后会自动指向下一个字节的位置，不会造成数据的覆盖
            fos.write('6');
            fos.write('5');
            //希望写入字符串内容"hello"
            fos.write("hello".getBytes());
            System.out.println("写入数据成功！");
            //3.关闭流对象并释放有关的资源
            fos.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

### 12.5 FileInputStream类(重中之重)

(1)基本概念
`java.io.FileInputStream`类主要用于从输入流中读取图像数据之类的字节流。

(2)常用的方法
`FileInputStream(String name)`
\- 根据参数指定的文件名来构造对象。

`int read()`
\- 用于读取单个字节。
\- 若读取到文件末尾则返回-1，否则返回实际读到的数据内容。

`int read(byte[] b, int off, int len)`
\- 用于从输入流中读取len个字节的数据放入数组b中下标从off开始的位置。
\- 若读取到文件末尾则返回-1，否则返回实际读到的字节个数。

`int read(byte[] b)`
\- 用于从输入流中读取b.length个字节的数据放入数组b中。

`int available()`
\- 用于获取该输入流所关联文件的大小。

`void close()`

```java
public class TestFileInputStream {
    public static void main(String[] args) {
        try{
            //1.构造FileInputStream类型的对象与c:/a.txt文件关联
            FileInputStream fis = new FileInputStream("c:/a.txt");
            //2.读取文件中的数据内容并打印出来
            //默认从文件开头位置来读取内容
            /*
            int num = fis.read();
            System.out.println("读取到的单个字节是：" + num 
                    + "，对应字符：" + (char)num); //65  'A'
            //每次读取一个字节后，则读取的位置自动指向下一个字节
            num = fis.read();
            System.out.println("读取到的单个字节是：" + num 
                    + "，对应字符：" + (char)num); //54  '6'
            */
            /*
            //以单个字节为单位使用循环读取所有内容
            int num = 0;
            while((num = fis.read()) != -1){
                System.out.println("读取到的单个字节是：" + num 
                        + "，对应字符：" + (char)num); 
            }
            */
            /*
            //读满字节数组中的一部分空间
            byte[] bArr = new byte[20];
            //表示从文件开头位置读取3个字节放入数组bArr中下标从1开始的位置上
            int res = fis.read(bArr, 1, 3);
            System.out.println("读取到的内容是：" + new String(bArr) 
                    + "，读到的数据大小是：" + res);
            */
            //读满整个字节数组，表示声明一个与fis关联的文件大小一样的一维数组
            byte[] bArr = new byte[fis.available()];
            int res = fis.read(bArr);
            System.out.println("读到的内容是：" + new String(bArr) 
                    + "，读到的数据大小是：" + res);
            //3.关闭流对象并释放有关的资源
            fis.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

案例：

```java
public class TestFileCopy {
    public static void main(String[] args) {
        try{
            //1.构造FileInputStream类型的对象与c:/a.txt文件关联
            FileInputStream fis = new FileInputStream
            ("D:/封装.wmv");
            //2.构造FileOutputStream类型的对象与c:/b.txt文件关联
            FileOutputStream fos = new FileOutputStream("C:/封装1.wmv");
            //3.不断地读取输入流中的数据内容写入到输出流中
            //方式一：以字节为单位进行拷贝
            //缺点：只要文件稍大则拷贝的效率极低
            /*
            int res = 0;
            while((res = fis.read()) != -1){
                fos.write(res);
            }
            */
            //方式二：准备一个与文件大小一样的字节数组
            //       一次性将文件中的所有内容读取到字节数组后一次性整体写进去
            //缺点：当文件很大时，无法申请和文件大小一样的一维数组
            //      因为真实物理内存不足
            /*
            System.out.println("文件的大小是：" + fis.available());
            byte[] bArr = new byte[fis.available()];
            int res = fis.read(bArr);
            System.out.println("读取到的数据大小是：" + res);
            fos.write(bArr);
            */
            //方式三：准备一个相对合理的一维数组，使用该数组为基本单位实现拷贝
            //推荐该方式
            byte[] bArr = new byte[1024*8];
            int res = 0;
            while((res = fis.read(bArr)) != -1){
                fos.write(bArr, 0, res);
            }
            System.out.println("拷贝文件成功！");
            //4.关闭流对象并释放有关的资源
            fos.close();
            fis.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

### 12.6 DataOutputStream类(会用即可)

(1)基本概念
`java.io.DataOutputStream`类用于将Java基本数据类型的变量写入输出流中。

(2)常用的方法
`DataOutputStream(OutputStream out)`
\- 根据参数指定的引用构造对象。
\- 其中OutputStream类是个抽象类，实参需要传递子类的对象。

`void writeInt(int v)`
\- 用于将参数指定的整数以4字节的方式写入输出流中，先写入高字节。
\- 127: 0000 0000 0000 0000 0000 0000 0111 1111
高 => 低 void close()

```java
public class TestDataOutputStream {
    public static void main(String[] args) {
        try{
            //1.构造DataOutputStream类型的对象与c:/a.txt文件关联
            DataOutputStream dos = new DataOutputStream(
                    new FileOutputStream("c:/a.txt"));
            //2.准备一个int类型的变量并指定初始值
            int num = 65;
            //3.将int类型的变量以4字节的方式整体写入输出流中，先写入高字节
            //65:0000 0000   0000 0000   0000 0000   0100 0001
            //     高                                        低
            //   0-空字符            空字符             空字符             A
            //dos.writeInt(num);
            //将int类型变量的1个字节写入输出流中，默认写入低字节  A
            dos.write(num);
            System.out.println("写入数据成功！");
            //4.关闭流对象并释放有关的资源
            dos.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

### 12.7 DataInputStream类(会用即可)

(1)基本概念
`java.io.DataInputStream`类用于从输入流中读取Java基本数据类型的内容。

(2)常用的方法
`DataInputStream(InputStream in)
\- 根据参数指定的引用来构造对象。
\- 其中InputStream类是个抽象类，实参需要传递子类的对象。

`int readInt()`
\- 用于读取4个字节的整数数据并返回。

`void close()`

```java
public class TestDataInputStream {
    public static void main(String[] args) {
        try{
            //1.构造DataInputStream类型的对象与c:/a.txt文件关联
            DataInputStream dis = new DataInputStream(
                    new FileInputStream("c:/a.txt"));
            //2.读取文件中的整数数据并打印出来
            //要求从dis中一次性要读取4个字节
            //int res = dis.readInt();
            //从dis中读取1个字节的数据内容
            int res = dis.read();
            System.out.println("读取到的整数数据是：" + res); //65
            //3.关闭流对象并释放有关的资源
            dis.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

### 12.8 BufferedWriter类(重点)

(1)基本概念
`java.io.BufferedWriter`类用于写入单个字符、字符数组以及字符串到输出流中。

(2)常用的方法
`BufferedWriter(Writer out)`
\- 根据参数指定的引用构造对象。
\- 其中Writer类是个抽象类，因此实参需要传递子类的对象。

`void write(int c)`
\- 用于写入单个字符。

`void write(char[] cbuf, int off, int len)`
\- 用于将字符数组cbuf中下标从off开始的len个字符写入输出流。

`void write(char[] cbuf)`
\- 用于将字符数组cbuf中所有内容写入。

`void write(String str)`
\- 用于将参数指定的字符串内容写入输出流。

`void newLine()`
\- 用于写入行分隔符，不一定是\n字符。

void close()

```java
public class TestBufferedWriter {
    public static void main(String[] args) {
        try{
            //1.构造BufferedWriter类型的对象与c:/a.txt文件关联
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(
                    new FileOutputStream("c:/a.txt")));
            //2.使用write()方法向输出流中写入数据内容
            //向输出流中写入单个字符
            bw.write('1');
            bw.write('2');
            //向输出流中写入字符数组的一部分以及整个字符数组
            char[] cArr = {'h', 'e', 'l', 'l', 'o'};
            //写入cArr中下标从1开始的2个字符  el
            bw.write(cArr, 1, 2);
            //写入整个字符数组  hello
            bw.write(cArr);
            //向输出流中写入整个字符串  world
            bw.write("world");
            //向输出流中写入行分隔符  不一定是'\n'
            bw.newLine();
            //向输出流中写入单个字符
            //bw.write('3');
            System.out.println("写入数据成功！");
            //3.关闭流对象并释放有关的资源
            bw.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

### 12.9 BufferedReader类(重点)

(1)基本概念
`java.io.BufferedReader`类主要用于从输入流中读取单个字符、字符数组以及一行字符串。

(2)常用的方法
`BufferedReader(Reader in)`
\- 根据参数指定的引用构造对象。
\- 其中Reader类是个抽象类，实参需要传递子类的对象。

`int read()`
\- 用于从输入流中读取单个字符。
\- 若读取到文件末尾则返回-1，否则返回实际读取到的数据内容对应的整数值。

`int read(char[] cbuf, int off, int len)`
\- 用于从输入流中读取len个字符放入数组cbuf中下标从off开始的位置。
\- 若读取到文件末尾则返回-1，否则返回实际读取到的字符数。

`int read(char[] cbuf)`
\- 用于从输入流中读取cbuf.length个字符到数组cbuf中。

`String readLine()`
\- 用于从输入流中读取一行字符串内容。
\- 若读取到文件末尾则返回null。

`void close()`

```java
public class TestBufferedReader {
    public static void main(String[] args) {
        try{
            //1.构造BufferedReader类型的对象与c:/a.txt文件关联
            BufferedReader br = new BufferedReader(new InputStreamReader(
                    new FileInputStream("c:/a.txt")));
            //2.读取文件中的内容并打印出来
            //以字符为单位来读取文件中的所有内容并打印
            /*
            int num = 0;
            while((num = br.read()) != -1){
                //在windows系统中行分隔符代表：\r\n
                System.out.println("读取到的字符内容是：" + (char)num
                        + ", 对应的ASCII是：" + num);
            }
            */
            //以字符数组为缓冲池来读取数据内容
            char[] cArr = new char[20];
            /*
            //读满数组的一部分空间，从文件中读取5个字符放入数组cArr中下标从0开始的位置
            int res = br.read(cArr, 0, 5);
            //System.out.println("读取到的数据内容是：" + new String(cArr) 
            //      + "，读取到的数据大小是：" + res); //5
            System.out.println("读取到的数据内容是：" + new String(cArr, 0, res) 
                    + "，读取到的数据大小是：" + res); //5
            */
            //读满整个数组
            /*
            int res = br.read(cArr);
            System.out.println("读取到的数据内容是：" + new String(cArr, 0, res) 
                    + "，读取到的数据大小是：" + res); //16
            */
            //读取一行字符串内容并打印出来
            String str1 = br.readLine();
            System.out.println("读取到的数据内容是：" + str1); 
            //3.关闭流对象并释放有关的资源
            br.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```

### 12.10 PrintStream类(重点)

(1)基本概念
`java.io.PrintStream`类主要用于实现各种数据的打印并自动刷新。

(2)常用的方法
`PrintStream(OutputStream out)`
\- 根据参数指定的引用构造对象。
\- 其中OutputStream类是个抽象类，实参需要传递子类的对象。

`void print(String s)`
\- 用于打印参数指定的字符串内容。

`void println(String x)`
\- 用于打印参数字符串后终止该行。

`void close()`

```java
public class TestPrintStream {
    public static void main(String[] args) {
        try{
            //1.构造PrintStream类型的对象与c:/a.txt文件关联
            PrintStream ps = new PrintStream(new FileOutputStream("c:/a.txt"));
            //2.向文件中写入字符串内容
            ps.println("写完这个程序就下课了！");
            System.out.println("写入数据内容成功！");
            //3.关闭流对象并释放有关的资源
            ps.close();
        }catch(Exception e){
            e.printStackTrace();
        }
    }
}
```







## 第13 章 多线程

### 13.1 基本概念

程序 - 数据结构 + 算法，主要指存放在硬盘上的可执行文件。
进程 - 主要指运行在内存中的程序。

目前主流的操作系统都支持多进程，是为了让操作系统可以同时执行多个任务，但进程是重量级的，新建进程对系统资源的消耗比较大，因此进程的数量比较局限。
线程是进程内部的程序流，也就是说操作系统支持多进程，而每个进程的内部又支持多线程，并且线程是轻量级的，会共享所在进程的资源，因此以后主流的开发都采用多线程技术。
多线程技术是采用时间片轮转法来保证并发执行的效果，所谓并发就是指宏观并行微观串行的机制。

### 13.2 线程的创建(重中之重)

(1)创建的方式
`java.lang.Thread`类用于描述线程，Java虚拟机允许运行多个执行线程，而线程的创建和启动方式如下：
a.自定义类继承`Thread`类并重写`run()`方法，创建该类的对象调用`start()`方法。
b.自定义类实现`Runnable`接口并重写`run()`方法，创建该类的对象作为实参来构造`Thread`类的对象，然后使用`Thread`类对象调用`start()`方法。

c.自定义类实现 Callable 接口（了解）

1. 实现 Callable 接口，需要返回值类型：implements Callable<boolean> 
2. 重写 call 方法，需要抛出异常：public void call ()
3. 创建目标对象：TestThread t1 = new TestThread3();
4. 创建执行服务：ExecutorService ser = Executors.newFixedThreadPool(1);
5. 提交执行：Future<boolean> result1 = ser.submit(t1);
6. 获取结果：boolean r1 =result1.get()
7. 关闭服务：ser.shutdownNow();

(2)相关的方法
`Thread()` - 使用无参形式构造对象。

`Thread(String name)` - 根据参数指定的名称来构造对象。

`Thread(Runnable target)` - 根据参数指定的引用来构造对象。

`Thread(Runnable target, String name)` - 根据参数指定引用和名称来构造对象。

`void run()` - 若使用Runnable接口构造对象后调用该方法，则最终调用Runnable引用指向实现类中的run()方法，否则调用该方法则表示啥也不干。
测试run方法：

```java
public class TestThreadRun {
    public static void main(String[] args) {
        //1.声明Thread类型的引用指向Thread类型的对象  
        Thread t1 = new Thread();
        //2.调用run()方法  由源码分析可知：run()方法确实啥也不干
        t1.run();
        System.out.println("让我们来看看run()方法到底做了什么呢？");
    }
}
```

重写run方法：

```java
public class TestSubThreadRun extends Thread {
    @Override
    public void run(){
        System.out.println("我就是重写以后的run方法，因为Thread类的run方法啥也不干哦");
    }
    public static void main(String[] args) {
        //1.声明Thread类型的引用指向TestSubThreadRun类的对象
        //父类类型的引用指向子类的对象，形成了多态
        Thread t1 = new TestSubThreadRun();
        //2.调用run()方法，运行阶段调用重写以后的run()方法
        t1.run();
    }
}  
```

`void start()` - 用于启动线程，Java虚拟机会自动调用该线程的run()方法。

```java
public class TestSubThreadStart extends Thread {
    @Override
    public void run(){
        for(int i = 0; i < 50; i++){
            System.out.println("run方法中：i = " + i);
        }
    }
    public static void main(String[] args) {
        //1.声明Thread类型的引用指向子类的对象
        Thread t1 = new TestSubThreadStart();
        //2.调用start()方法
        t1.start();   //run方法和main方法的打印通常会有交错
        //t1.run();   //普通方法的调用，直到run方法的打印结束之后再打印main方法
        for(int i = 0; i < 50; i++){
            System.out.println("-------------main方法中：i = " + i);
        }
    }
} 
```

(3)原理分析
a.执行`main()`方法的线程叫做主线程，执行`run()`方法的线程叫做子/新线程。
b.对于`start()`方法调用代码以及之前的代码来说，由主线程执行一次，当start()方法调用结束后，则线程的个数瞬间由1个变成了2个，其中新启动的线程去执行run()方法，原来的主线程继续向下执行，两个线程各自独立运行。
c.当`run()`方法结束后则子线程结束，当`main()`方法结束后则主线程结束，两个线程的执行先后次序没有明确的规定，由**系统调度算法来决定**。

```java
public class TestSubRunnableStart implements Runnable {
    @Override
    public void run() {
        for(int i = 0; i < 50; i++){
            System.out.println("run方法中：i = " + i);
        }
    }
    public static void main(String[] args) {
        //1.声明TestSubRunnableStart类型的引用指向该类型的对象
        TestSubRunnableStart tsrs = new TestSubRunnableStart();
        //tsrs.start(); error
        //2.使用该类型的对象作为实参构造Thread类型的对象
        Thread t1 = new Thread(tsrs);
        //3.使用Thread类型的对象调用start方法
        t1.start();
        for(int i = 0; i < 50; i++){
            System.out.println("-------------main方法中：i = " + i);
        }
        //思考：线程创建的两种方式各自的优缺点是什么？
    }
}
```

注意：
继承方式创建和启动线程的代码相对简单，但Java语言中只支持单继承，若该类继承Thread类后则无法继承其它类，而实现接口的方式虽然代码复杂，但不影响该类继承其它类以及实现其它接口，因此以后的开发中推荐使用实现接口的方式。

```java
public class TestThreadNoName {
    public static void main(String[] args) throws InterruptedException {
        //匿名内部类的语法格式：
        //父类/接口类型 引用变量名 = new 父类/接口类型(){  方法的重写 };
        //1.使用父类和匿名内部类的方式来创建和启动线程
        /*
        Thread t1 = new Thread(){
            @Override
            public void run(){
                System.out.println("张三说：在吗？");
            }
        };
        t1.start();
        */
        new Thread(){
            @Override
            public void run(){
                System.out.println("张三说：在吗？");
            }
        }.start();
        //2.使用接口和匿名内部类的方式创建并启动线程
        /*
        Runnable ra = new Runnable(){
            @Override
            public void run(){
                System.out.println("李四说：不在！");
            }
        }; 
        Thread t2 = new Thread(ra);
        t2.start();
        */
        new Thread(new Runnable(){
            @Override
            public void run(){
                System.out.println("李四说：不在！");
            }
        }).start();
        Thread.sleep(1000);
        System.out.println("对你们两个也是够了！！！");
    }
}  
```

### 13.3 线程的编号和名称(会用即可)

`long getId()` - 用于获取线程的标识符/编号。

`String getName()` - 用于获取线程的名称。

`void setName(String name)` - 用于更改线程的名称。

`static Thread currentThread()` - 用于获取当前正在执行线程的引用并返回。

```java
public class TestThreadIdName extends Thread{
    public TestThreadIdName(String string) {
        super(string); //调用父类的有参构造方法
    }
    @Override
    public void run(){
        System.out.println("当前线程的编号是：" + getId()   //10
            + ", 名称是：" + getName());    //Thread-0 zhangfei
        //修改线程的名称
        setName("guanyu");
        System.out.println("修改后的编号是：" + getId()   //10
        + ", 名称是：" + getName());    //guanyu
    }
    public static void main(String[] args) {
        TestThreadIdName ttin = new TestThreadIdName("zhangfei");
        ttin.start();
        //执行下面代码的线程一定是主线程，当前正在执行的线程就是主线程
        Thread t1 = Thread.currentThread();
        System.out.println("主线程的编号是：" + t1.getId());
        System.out.println("主线程的名称是：" + t1.getName());
    }
}
```

### 13.4 线程的状态和方法

#### 13.4.1 线程的主要状态(了解、笔试题)

新建状态
\- 当线程对象使用new关键字创建完毕后进入的状态。
\- 此时线程还没有开始执行。
就绪状态
\- 当线程对象调用start()方法后进入的状态。
\- 此时线程依然没有开始执行。
运行状态
\- 当线程调度器调度就绪线程后进入的状态。
\- 此时线程开始执行。
\- 当时间片执行完毕后线程的任务没有完成时回到就绪状态。
消亡状态
\- 当时间执行完毕后线程的任务已经完成时进入的状态。
\- 此时线程已经终止。
阻塞状态
\- 当线程执行的过程中发生了阻塞事件后进入的状态，如：sleep()方法。
\- 当阻塞状态解除后回到就绪状态。

#### 13.4.2 线程的常用方法(重点)

`static void yield()`
\- 当前线程让出处理器(离开Running状态)，使当前线程进入Runnable状态等待

`static void sleep(long millis)`
\- 用于使得调用线程休眠参数指定的毫秒数。

```java
public class TestThreadSleep extends Thread {
    private boolean flag = true;
    @Override
    public void run(){
        while(flag){
            Date d1 = new Date();
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            System.out.println(sdf.format(d1));
            //这里不能抛出异常是因为 子类重写的方法不能抛出更大的异常
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }
        }
    }
    public static void main(String[] args) {
        TestThreadSleep tts = new TestThreadSleep();
        tts.start();
        System.out.println("主线程开始等待...");
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        //停止子线程执行
        //tts.stop();
        tts.flag = false; //推荐方式
        System.out.println("等待结束！");
    }
}
```

`int getPriority()`
\- 用于获取线程的优先级。

`void setPriority(int newPriority)`
\- 用于设置线程的优先级。
\- 优先级高的线程不一定先执行，但是该线程获得CPU时间片的机会更多一些。

```java
public class TestThreadPriority extends Thread {
    @Override
    public void run(){
        //默认优先级是5  一般/正常的优先级
        //System.out.println("子线程的优先级是：" + getPriority());
        for(int i = 0; i < 20; i++){
            System.out.println("子线程中：i = " + i);
        }
    }
    public static void main(String[] args) {
        TestThreadPriority ttp = new TestThreadPriority();
        ttp.setPriority(MAX_PRIORITY);  
        ttp.start();
        //System.out.println("主线程的优先级是：" 
        //      + Thread.currentThread().getPriority());
        for(int i = 0; i < 20; i++){
            System.out.println("-------主线程中：i = " + i);
        }
    }
} 
```

`void join()`
\- 用于等待调用线程终止。

`void join(long millis)`
\- 用于等待线程的最长时间为参数指定的毫秒数。

```java
public class TestThreadJoin extends Thread {
    @Override
    public void run(){
        System.out.println("倒计时开始...");
        for(int i = 10; i > 0; i--){
            System.out.println(i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println("七夕快乐！！！");
    }
    public static void main(String[] args) {
        TestThreadJoin ttj = new TestThreadJoin();
        ttj.start();
        System.out.println("主线程开始等待...");
        try {
            //当前正在执行的线程等待ttj这个线程，也就是主线程等待子线程
            //ttj.join();
            //等待的最长时间为5秒
            ttj.join(5000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //System.out.println("终于等到你，还好没放弃！！！");
        System.out.println("可惜不是你，陪我到最后!");
    }
}
```

`boolean isDaemon()`
\- 用于判断该线程是否为守护线程。

`void setDaemon(boolean on)`
\- 用于设置该线程为守护线程。
\- 该方法必须在启动线程前调用。
\- 当所有非守护线程结束后，则守护线程会随之结束，此时Java虚拟机退出。

```java
public class TestDaemon {
    public static void main(String[] args) {
        Thread rose = new Thread() {
            @Override
            public void run() {
                for(int i=0;i<5;i++) {
                    System.out.println("rose:let me go!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    }   
                }
                System.out.println("rose:啊啊啊啊AAAAAAaaaaaa....");
                System.out.println("噗通!");
            }
        };
        Thread jack = new Thread() {
            @Override
            public void run() {
                while(true) {
                    System.out.println("jack:you jump!i jump!");
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                    }
                }
            }
        };
        //注意，设置守护线程的工作必须在线程启动前进行
        jack.setDaemon(true);
        jack.start();   

        rose.start();
    }
}
```



### 13.5 线程的同步机制(重点)

#### 13.5.1 基本概念

当多个线程同时访问同一种共享资源时可能会造成数据的不一致等问题，此时就需要对多个线程之间进行协调和通信，该机制就叫线程的同步机制。
如：
银行以前 开户 存折
银行现在 开户 存折 银行卡 对应同一个账户

账户类：

```java
public class Account implements Runnable {
    private int balance;
    Demo dm = new Demo();

    public Account() {
        super();
    }
    public Account(int balance) {
        super();
        setBalance(balance);
    }

    public int getBalance() {
        return balance;
    }
    public void setBalance(int balance) {
        if(balance >= 0){
            this.balance = balance;
        }else{
            System.out.println("金额不合理！！！");
        }
    }

    //由源码分析可知：this就是测试类中的acc变量
    //由于两个线程是采用同一个acc创建的，因此两个线程使用同一个this
    @Override
    public /*synchronized*/ void run() {
        //synchronized(this){
        System.out.println("线程" + Thread.currentThread().getName() + "启动...");
        synchronized(dm){  //多个线程共同使用一把锁，可以锁住
            //synchronized(new Demo()){ //每个线程都有自己的一把锁，锁不住
            //模拟去银行后台数据库查询账户余额
            int temp = getBalance(); //int temp = 1000;  int temp = 1000;
            //模拟取款200元的过程
            if(temp >= 200){
                System.out.println("正在出钞，请稍后...");
                try {
                    Thread.sleep(10000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                temp -= 200; //temp=800; temp=800;
                System.out.println("请取走您的钞票！");
            }else{
                System.out.println("余额不足！请核对您的账户余额！");
            }
            //模拟将最新的余额写入后台数据库中
            setBalance(temp); //balance=800; balance=800;
        }
    }
}

class Demo{}
```

测试类：

```java
public class TestAccount {
    public static void main(String[] args) {
        Account acc = new Account(1000);
        Account acc2 = new Account(1000);
        Thread t1 = new Thread(acc);
        //Thread t2 = new Thread(acc);
        Thread t2 = new Thread(acc2);
        t1.start();
        t2.start();
        System.out.println("主线程开始等待...");
        try {
            t1.join();
            //t2.start(); //当线程一执行完毕取款操作之后，再启动线程二避免问题的发生
            t2.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("取款结束，当前账户余额为：" + acc.getBalance());//600
    }
}
```

#### 13.5.2 解决方案

引发问题：由程序可知，当两个线程同时对同一个账户进行取款时会导致账户余额不合理！
引发原因：线程一还没有执行完毕取款操作时，线程二已经开始执行。
解决方案：**让多个线程的并发操作修改为串行操作即可。**
带来缺点：串行操作的范围应该越小越好，否则会影响多线程的执行效率。

#### 13.5.3 实现方式

Java语言中提供了synchronized关键字来表示同步锁/对象锁，来保证线程操作的原子性，而具体使用方式如下：
(1)使用同步语句块的方式实现

```java
synchronized(对象的引用){
    编写所有需要锁定的代码;
}
```

(2)使用同步方法的方式实现

```java
使用synchronized关键字修饰整个方法，表示锁定该方法的所有代码；该方式等价于：
synchronized(this){ 
      方法体的代码; 
}
```

-在使用同步块时，应当尽量在允许的情况下减少同步范围，以提高并发的执行效率
-多个需要同步的线程在访问该同步块时，看到的应该是同一个所对象引用。否则达不到同步效果

#### 13.5.4 原理分析(尽量理解)

当多个线程启动后会同时抢占共享资源，若其中一个线程抢到了同步锁则其它线程进入阻塞状态，直到该线程执行完毕所有锁定代码后自动释放同步锁，而阻塞的所有线程重新抢占同步锁，抢不到的线程继续阻塞。

#### 13.5.5 死锁(了解)

线程一执行的代码：

```java
public void run(){

    synchronized(a){  //持有对象锁a，等待对象锁b
       synchronized(b){
           ...
       }
    }
}
```

线程二执行的代码：

```java
public void run(){

    synchronized(b){  //持有对象锁b，等待对象锁a
       synchronized(a){
           ...
       }
    }
}   
```

注意：
在以后的开发中尽量不要使用同步语句块的嵌套结构。
案例：
哲学家进餐问题

### 13.6 Object类中的方法

`void wait()`
\- 用于使得当前线程进入等待状态，直到其它线程调用唤醒的方法为止。

`void wait(long timeout)`
\- 用于使得当前线程进入等待状态，直到其它线程唤醒或参数指定的毫秒时间过去为止

`void notify()`
\- 用于唤醒等待的单个线程。

`void notifyAll()`
\- 用于唤醒等待的所有线程。

生产者消费者模型：
线程池：







## 第14 章 网络编程

### 14.1 网络编程的常识

#### 14.1.1 七层网络模型(了解)

为了保证数据传输的可靠和安全等，ISO将数据的传递从逻辑上划分为以下七层：
应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
当发送数据时，需要按照上述七层进行层层加包然后发送出去。
当接收数据时，需要按照上述七层相反的次序层层拆包再解析出来。

#### 14.1.2 常用的协议(了解)

http - 超文本传输协议，用于浏览网页时使用
ftp - 文件传输协议，用于上传和下载文件时使用
tcp - 传输控制协议，用于网络通信时使用
udp - 用户数据报协议，用于网络通信时使用
ip - 互联网协议，是上述协议的底层协议

协议 - 本质上就是一种规则，用于约定双方通信的机制。

#### 14.1.3 IP地址(重点)

如：
192.168.1.1 - 是绝大多数路由器的登录地址，进行MAC地址的过滤。

IP地址是互联网中的唯一地址标识，本质上是由32位二进制组成的整数，叫做IPv4，当然也有128位二进制组成的整数，叫做IPv6，目前的主流是IPv4.
日常生活中采用点分十进制表示法进行IP地址的描述，也就是让每个字节的二进制转换为一个十进制整数，不同的十进制整数之间采用小数点隔开。
如： 0x01 02 03 04(十六进制) => 1.2.3.4

查看IP地址的方式
windows系统：在dos窗口中使用ipconfig或者ipconfig/all命令查看
linux系统： 在终端窗口中使用ifconfig或者/sbin/ifconfig命令查看

#### 14.1.4 端口号

IP地址 - 可以定位到具体某一台设备。
端口号 - 可以定位到具体某一个进程。
网络编程需要提供：IP地址 + 端口号。

端口号本质上是由16位二进制组成的整数，范围是：0 ~ 65535，其中0 ~ 1024之间的端口号一般被系统占用，因此编程从1025开始使用。

### 14.2.基于tcp协议的编程模型(重点)

#### 14.2.1 编程模型

服务器：
(1)创建ServerSocket类型的对象并提供端口号；
(2)等待客户端的连接请求，调用accept()方法；
(3)使用输入输出流进行通信；
(4)关闭ServerSocket；
客户端：
(1)创建Socket类型的对象并提供服务器的IP地址和端口号；
(2)使用输入输出流进行通信；
(3)关闭Socket；

#### 14.2.2 相关类和方法的解析

(1)ServerSocket类
`java.net.ServerSocket`类是用于描述服务器的套接字。

`ServerSocket(int port)` - 根据参数指定的端口号构造对象。

`Socket accept()` - 侦听并接收到此套接字的连接请求。

`void close()` -关闭连接



(2)Socket类
`java.net.Socket`类用于描述客户端的套接字，是两台设备间通信的端点。

`Socket(String host, int port)` - 根据参数指定的主机名和端口号构造对象。

`InputStream getInputStream()` - 用于获取该套接字的输入流。

`OutputStream getOutputStream()` - 用于获取该套接字的输出流。

`void close()` -关闭连接



### 14.3.tcp协议和udp协议的比较(笔试题)

#### 14.3.1 tcp协议

- 传输控制协议，是一种面向连接的协议，类似于打电话。
- 建立连接 => 进行通信 => 断开连接
- 在通信的整个过程中全程保持连接
- 该协议保证了数据传输的可靠性和有序性
- 是一种全双工的字节流通信方式
- 服务器压力比较大，资源消耗比较多，并且发送数据的效率相对比较低

#### 14.3.2 udp协议

- 用户数据报协议，是一种非面向连接的协议，类似于写信。
- 在通信的整个过程中不保持连接
- 不保证数据传输的可靠性和有序性
- 是一种全双工的数据报通信方式
- 服务器压力比较小，资源消耗比较少，并且发送数据的效率相对比较高

### 14.4.基于udp协议的编程模型(会用即可)

#### 14.4.1 编程模型

接收方：
(1)创建DatagramSocket类型的对象并提供端口号；
(2)创建DatagramPacket类型的对象用于接收数据并记录；
(3)调用receive()方法接收数据内容；
(4)关闭Socket；
发送方：
(1)创建DatagramSocket类型的对象；
(2)创建DatagramPacket类型的对象并提供接收方的通信地址和端口号；
(3)调用send()方法发送数据内容；
(4)关闭Socket；

#### 14.4.2 相关类和方法的解析

(1)DatagramSocket类
`java.net.DatagramSocket`类用于描述发送/接收数据的套接字。

`DatagramSocket()` - 使用无参方式构造对象。

`DatagramSocket(int port)` - 根据参数指定端口构造对象。

`void receive(DatagramPacket p)` - 用于接收数据并记录到参数指定的数据报中。

`void send(DatagramPacket p)` - 用于发送参数指定的数据报内容。

`void close()`



(2)DatagramPacket类
`java.net.DatagramPacket`类用于描述发送/接收的数据报。

`DatagramPacket(byte[] buf, int length)` - 用于接收数据报到参数中记录。

`DatagramPacket(byte[] buf, int length, InetAddress address, int port)`
\- 用于将参数指定的内容发送到参数指定的位置。

`InetAddress getAddress()` - 用于获取发送方/接收方的通信地址。

`int getPort()` - 用于获取发送方/接收方的端口号。

`int getLength()` - 用于获取发送/接收到的数据长度。



(3)InetAddress类
`java.net.InetAddress`类用于描述通信地址信息。

`static InetAddress getLocalHost()` - 用于获取本地主机的通信地址。

`static InetAddress getByName(String host)` - 用于获取指定主机的通信地址。