## 1. 线程简介

### 1.1 什么是线程和进程？

**何为进程？**

进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序既是一个进程从创建、运行到消亡的过程。

在Java中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称为主线程。

![image-20210128155850534](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20210128155850.png)

**何为线程？**

线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器、虚拟机栈和本地方法栈，**所以系统在产生一个线程，或是在各个线程之间切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

Java程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下：

```java
public class MultiThread {
    public static void main(String[] args) {
        // 获取 Java 线程管理 MXBean
        ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
        // 不需要获取同步的 monitor 和 synchronize 信息，仅获取线程和线程堆栈信息
        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
        // 遍历线程信息，仅打印线程 ID 和线程名称信息
        for (ThreadInfo threadInfo : threadInfos) {
            System.out.println("["+threadInfo.getThreadId()+"]"+threadInfo.getThreadName());
        }
    }
}
```

上述程序输出如下（输出结果可能不同，不用纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：

```java
[1]main //mian 线程，程序入口
[2]Reference Handler //清除 reference 线程
[3]Finalizer // 调用对象 finalize 方法的线程
[4]Signal Dispatcher // 分发处理给 JVM 信号的线程
[10]Common-Cleaner
[11]Monitor Ctrl-Break
```

从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。

### 1.2 线程与进程的关系、区别以及优缺点

**从 JVM 的角度说进程和线程之间的关系**

#### 图解进程和线程的关系

下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。

> 如果你对 Java 内存区域（运行时数据区）这部分知识不太了解的话可以阅读这篇文章：[可能是把Java内存区域将的最清楚的一篇文章](https://github.com/Snailclimb/JavaGuide/blob/3965c02cc0f294b0bd3580df4868d5e396959e2e/Java%E7%9B%B8%E5%85%B3/%E5%8F%AF%E8%83%BD%E6%98%AF%E6%8A%8AJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%AE%B2%E7%9A%84%E6%9C%80%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0.md)

  ![image-20210128164627664](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20210128164627.png)

从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区（JDK1.8 之后的元空间）**资源，但是每个线程有自己的**程序计数器、虚拟机栈 和 本地方法栈。**

**总结：** 线程 是 进程划分成的更小运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反

下面是该知识点的扩展内容！

下面来思考这样一个问题：为什么**程序计数器、虚拟机栈** 和 **本地方法栈**是线程私有的呢？为什么 **堆** 和 **方法区**是线程共享的呢？

#### 程序计数器为什么是私有的？

程序计数器主要有下面两个作用：

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
2. 在多线程情况下，程序计数器用于记录当前线程的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。

所以，程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置。**

#### 虚拟机栈和本地方法栈为什么是私有的？

- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是：**虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**在 HotSpot 虚拟机中和 Java虚拟机合二为一。

所以，为了**保证线程中的局部变量不被别的线程访问到，**虚拟机栈和本地方法栈是线程私有的。

#### 一句话简单了解堆和方法区

堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象（所有对象都在这里分配内存），方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

### 1.3 为什么要使用多线程？

先从总体上来说：

- **从计算机底层来说：** 线程可以比作是轻量级的进程，是程序执行的最小单位，线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **从当代互联网发展趋势来说：** 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正式开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

再深入到计算机底层来探讨：

- **单核时代：** 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
- **多核时代：** 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。

### 1.4 使用多线程可能带来什么问题？

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄露、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。

## 2. 线程实现

### 2.1 三种创建方式

- **Thread class：** 继承 Thread 类（重点）
- **Runnable接口：** 实现 Runnable 接口（重点）
- **Callable接口：** 实现 Callable 接口（了解）

**注意：** 推荐使用实现 Runnable接口方式创建线程，避免单继承局限性，灵活方便，方便同一个对象被多个线程使用。

```java
public class TestCallable implements Callable<>{
    
}
```



## 3. 线程生命周期和状态

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java并发编程艺术》4.1.4 节）。

![image-20210128215403021](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20210128215403.png)

线程的说明周期并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：

![image-20210128221801915](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20210128221801.png)

由上图可以看出：线程创建之后他将处于 **NEW（新建）** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **READY（可运行）** 状态。可运行状态的线程或得了 CPU 时间片（timelice）后就处于 **RUNNING（运行）** 状态。

> 操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING状态，它只能看到 RUNNABLE 状态，所以 Java 系统一般将这两种状态统称为 **RUNNABLE（运行中）**状态。

![image-20210128221853097](https://picture-bed01.oss-cn-beijing.aliyuncs.com/img/20210128221853.png)

当线程执行 `wait()` 方法之后，线程进入 **WAITING（等待）** 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 **TIME_WAITTING（超时等待）** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep (long millis)` 方法或 `wait (long millis)` 方法可以将 Java 线程置于 TIME_WAITIING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态 。当线程调用同步时，在没有获取到锁的情况下，线程将会进入到 **BLOCKED（阻塞）** 状态。线程在执行 Runnable 的 `run()` 方法之后将会进入到 **TERMINATED（终止）** 状态。

## 4. 线程方法

### 4.1 停止线程

- 不推荐使用 JDK 提供的 stop()、destroy() 方法【已废弃】
- 推荐线程自己停止下来
- 建议使用一个标志位进行终止变量当 flag = false，则终止线程运行

```java
//示例代码
public class TestStop implements Runnable {
    // 1.线程中定义线程体使用的标识
    private boolean flag = true;
    
    @Override
    public void run() {
        // 2.线程体使用该标识
        while (flag) {
            System.out.println("run...Thread");
        }
    }
    
    // 3.对外提供方法改变标识
    public void stop () {
        this.flag = false;
    }
}
```

### 4.2 线程休眠_sleep()

- sleep(long millis) 指定当前线程阻塞的毫秒数
- sleep 存在异常 InterruptedException
- sleep 时间到达后线程进入 RUNNABLE 状态
- sleep 可以模拟网络延时、倒计时等
- 每个对象都有一个锁，sleep 不会释放锁

### 4.3 线程礼让_yield()

- 礼让进程，让当前正在执行的线程暂停，但不阻塞
- 将线程从 RUNNING 状态 转为 READY 状态
- **让CPU重新调用，礼让不一定成功！看 CPU 心情**

### 4.4 线程强制执行_join()

- join 合并线程，待此线程执行完成后，在执行其他线程，其他线程阻塞
- 可以想象为插队

### 4.5 观察线程状态_State

Thread.State

- NEW
- RUNNABLE
- BLOCKED
- WAITING
- TIMED_WAITING
- TERMINATED

### 4.6 线程的优先级_priority

- Java 提供了一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。
- 线程的优先级用数字表示，范围从1~10
    - Thread.MIN_PRIORITY = 1;
    - Thread.MAX_PRIORITY = 10;
    - Thread.NORM_PRIORITY = 5;
- 使用以下方式改变或获取优先级
    - getPriority()    setPriority()
- 优先级的设定建议在 start() 调度前
- 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看 CPU 的调度

### 4.7 守护线程_daemon

- 线程分为**用户线程**和**守护线程**
- 虚拟机必须确保用户线程执行完毕
- 虚拟机不用等待守护线程执行完毕
- 如，后台记录操作日志、监控日志、垃圾回收等等

## 5. 线程同步机制

### 5.1 概念

处理多线程问题时，多个线程访问同一个对象，并且某些线程还想修改这个对象。这时候我们就需要线程同步。线程同步其实就是一种等待机制，多个需要同时访问此对象的线程进入这个 **对象的等待池** 形成队列，等待前面的线程使用完毕，下一个线程再使用。

形成条件：队列 + 锁

### 5.2 使用线程同步可能带来什么问题？

由于同一进程的多个线程共享同一块存储空间，在带来方便的同时，也带来了访问冲突问题，为了保证数据在方法中被访问的正确性，在访问时加入 **锁机制 synchronized** ，当一个线程或得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可。存在以下问题：

1. 一个线程持有锁会导致其他所有需要此锁的线程挂起；
2. 在多线程竞争下，加锁、释放锁会导致比较多的上下文切换 和调度延时，引起性能问题；
3. 如果一个优先级高的线程等待一个优先级地的线程释放锁 会导致优先级倒置，引起性能问题。

### 5.3 同步方法

由于我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套机制，这套机制就是 synchronized 关键字，它包括两种用法： synchronized 方法 和 synchronized 块。

```java
public synchronized void method(int args){}
```

synchronized 方法控制对“对象”的访问，每一个对象对应一把锁，每个 synchronized 方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，知道该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行

### 5.4 同步块

```java
synchronized (obj) {}
```

**obj** 称之为 **同步监视器**

- **obj** 可以是任何对象，但是推荐使用共享资源作为同步监视器
- 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是 this ，就是这个对象本身，或者是 class

**同步监视器的执行过程：**

1. 第一个线程访问，锁定同步监视器，执行其中代码；
2. 第二个线程访问，发现同步监视器被锁定，无法访问；
3. 第一个线程访问完毕，解锁同步监视器；
4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问。

### 5.5 死锁

多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，都停止执行的情形。某一个同步块同时拥有 “**两个以上对象的锁**”时，就可能会发生 “死锁”的问题。

产生死锁的四个必要条件：

1. 互斥条件：一个资源每次只能被一个进程使用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件：进程已获得的资源，在未使用完之前，不能强行剥夺。
4. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。

只要想办法破坏其中任意一个或多个条件就可以避免死锁发生。

### 5.6 Lock（锁）

从 JDK 5.0 开始，Java 提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当。

java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源只爱你应先获得 Lock 对象

ReentrantLock 类实现了 Lock，他拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock ，可以显式加锁、释放锁

```java
public TestLock{
    TestLock2 testLock2 = new TestLock2();
    
    new Thread(testLock2).start();
    new Thread(testLock2).start();
    new Thread(testLock2).start();
}

class TestLock2 implements Runnable {
    int ticketNums = 10;
    
    // 定义lock锁
    private final ReentrantLock lock = new ReentrantLock();
    
    @Override
    public void run(){
        while (true){
            try {
                lock.lock();//加锁
                if (ticketNums>0){
                    try{
                        Thread.sleep(1000);
                    } catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    System.out.println(ticketNums--);
            	}else {
                	break;
            	}
            }finally {
                lock.unlock()://解锁
            }
        }
    }
}
```

**synchronized 与 Lock 的对比：** 

- Lock 是显式锁（需要手动开启和关闭锁），synchronized 是隐式锁，出了作用域自动释放。
- Lock 只有代码块锁，synchronized 有代码块锁 和 方法锁。
- 使用 Lock 锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多子类）
- 优先使用顺序：
    - Lock -> 同步代码块 -> 同步方法

## 6. 线程通信问题

### 应用场景： 生产者和消费者问题

- 假设仓库中只能存放一件产品，生产者将生产出来的产品放入仓库，消费者将仓库中产品取走消费。
- 如果仓库中没有产品，则生产者将产品放入仓库，否则停止生产并等待，直到仓库中的产品被消费者取走为止。
- 如果仓库中放有产品，则消费者可以将产品取走消费，否则停止消费并等待，直到仓库中再次放入产品为止。

**这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件。** 

- 对于生产者，没有生成产品之前，要通知消费者等待。而生产了产品之后，有需要马上通知消费者消费。
- 对于消费者，在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费
- 在生产者消费者问题中，仅有 synchronized 是不够的
    - synchronized 可阻止并发更新同一个共享资源，实现了同步
    - synchronized 不能用来实现不同线程之间的消息传递（通信）

Java 提供了几个方法解决线程之间的通信问题：

| 方法名             | 作用                                                         |
| ------------------ | ------------------------------------------------------------ |
| wait()             | 表示线程一直等待，知道其他线程通知，与 sleep 不同，会释放锁  |
| wait(long timeout) | 指定等待的毫秒数                                             |
| notify()           | 唤醒一个处于等待状态的线程                                   |
| notifyAll()        | 唤醒用一个对象上所有调用 wait() 方法的线程，优先级别高的线程优先调度 |

**注意： 均是 Object 类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出异常 IllegalMonitorStateException**

### 管程法

并发协作模型“生产者 / 消费者模式” ---> 管程法

- 生产者：负责生产数据的模块（可能是方法、对象、线程、进程）
- 消费者：负责处理数据的模块（可能是方法、对象、线程、进程）
- 缓冲区：消费者不能直接使用生产者的数据，他们之间有个 “缓冲区”

**生产者将生产好的数据放入缓冲区，消费者从缓冲区拿出数据**

### 信号灯法

并发协作模型“生产者 / 消费者模式” ---> 信号灯法

## 7. 线程池

> 池化思想相信大家已经屡见不鲜了，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。

**线程池** 提供了一种限制和管理资源（包括执行一个任务）。每个**线程池** 还维护一些基本统计信息，例如如完成任务的数量。

**使用线程池的好处**，来源《Java 并发编程艺术》：

- **降低资源消耗。** 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度。** 当任务到达时，任务可以不需要的等到线程创建就可以立即执行。
- **提高线程的可管理性。** 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控。

### 使用线程池

JDK 5.0 起提供了线程池相关 API ：**ExecutorService** 和 **Executors** 

ExecutorService ：真正的线程池接口。常见子类 ThreadPoolExecutor

- void executor(Runnable command) ：执行任务/命令，没有返回值，一般用来执行 Runnable
- <T> Future<T> submit(Callable<T> task) ：执行任务，有返回值，一般用来执行 Callable
- void shutdown()：关闭线程池

Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池。

## Reference

- 《深入理解 Java 虚拟机》
- 《实战 Java 高并发程序设计》
- 《Java 并发编程艺术》
- http://www.cnblogs.com/waterystone/p/4920797.html
- https://www.cnblogs.com/chengxiao/archive/2017/07/24/7141160.html
- https://www.journaldev.com/1076/java-threadlocal-example